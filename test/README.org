#+name: Wire-Cell Toolkit Testing

The Wire-Cell Toolkit (WCT) provides a large number of tests of different types.  This document describes how to exercise and develop them.  The ~wire-cell-toolkit~ provides assistance to running and developing tests in this sub-package (~wire-cell-toolkit/tests/~) and as part of the build system (~wire-cell-toolkit/waft/~).

* Types of tests

There are two cateogries of tests in WCT which differ in how they are developed and run.

- atomic :: a program requiring no input and producing no useful output (other than an exit status code).  An atomic test is processed automatically but must follow WCT test program conventions.
- variant :: a program requiring input files or command line parameters and which may produce output files (in addition to a required exit status code).  A variant test need not follow WCT test program conventions but requires manual registration.

In software development it is common to categorize a test as being either a *unit test* or an *integration test*.  These terms rely on a vague definition of a software "unit".  In WCT testing, there is no attempt to realize these categories.  However, *atomic* tests are expected to be written to test some smaller software parts and so tend toward being "unit" tests while *variant* tests, and particularly DAGs of several variant tests sharing files, tend toward being "integration" tests.

WCT uses the "Waf unit test" framework (via the ~wcb~ command).  Each "test" is performed by the execution of a test program.  A test is successful only when the program exits with a status code of 0 (usual Unix convention).  Test programs are run automatically as part of the WCT software build unless this running has been suppressed by the user.

* Executing tests

** Automatic execution

All tests will be built and executed by default when WCT is built.

#+begin_example
./wcb [ ... ]             # build everything and run all tests
#+end_example

Running tests greatly increases total build time.  Building and running tests can be *suppressed* with the ~--notests~ flag:

#+begin_example
./wcb --notests [ ... ]   # no tests
#+end_example

And, to include the atomic tests but suppress the variant tests:

#+begin_example
./wcb --nochecks [ ... ]  # just atomic unit tests
#+end_example

Note,  ~wcb~ caches the outcome of a  test, whether it succeeded or failed.  It will not rerun the test until the test source or its dependencies change.  However, all tests may be run again:

#+begin_example
./wcb --alltests
#+end_example

** Explicit execution

An individual test may be run explicitly via ~wcb~ by giving its "target".

#+begin_example
./wcb --target=test_testing
#+end_example

Note, this too is subject to caching of test outcomes described above.

** Direct execution

Test programs can also be executed directly.  Compiled tests are found under ~build/<pkg>/<testprogram>~ while interpreted test files are left in-place in the source tress.  Some example of directly running tests:

#+begin_example
./build/util/test_testing
wcsonnet cfg/test/test_wirecell.jsonnet
bats util/test/test_bats.bats
#+end_example

Notes:

- Test programs should not be (but some are) sensitive to the choice of the current working directory.  ~wcb~ runs tests from ~build/~ and prior to manually running a test the user may need to ~cd build/~.

- Some tests may require ~WIRECELL_PATH~ to be defined to include ~wire-cell-data~.

- ~wcb~ will first build WCT libraries and main programs before automatically running tests.  When running tests manually, be sure to these prior build steps are complete.

- Some atomic tests will output files which are not explicitly known to ~wcb~.  They should usually be written in the same directory as containing the executable (ie, under ~build/~) but some may write to the current working directory.

- See section below on [[BATS]]

* Built-in test system

WCT uses Waf's unit test framework with an overlay of conventions.

** Check programs

Source files found as:

#+begin_example
<pkg>/test/check_*.<ext>
#+end_example

will be compiled, but not run automatically.  They are made available for use in atomic or variant tests.

** Atomic tests

The build will compile, if needed, and automatically run *atomic tests* with source files found as:

#+begin_example
<pkg>/test/test_*.<ext>
#+end_example

Extensions of ~cxx~ or ~kokkos~ wil be compiled prior to running.  Interpreted scripts with extensions ~py, sh, bats, jsonnet~ will be run with their associated interpreter.  The check programs (above) are available for calling from these atomic tests as are various others.

** Variant tests

Variant tests are explicitly registered as ~wcb~ rules in a file found at:

#+begin_example
<pkg>/wscript_build
#+end_example

That code should utilize the return from a call to ~bld.smplpkg()~ as a context manager though which to register ~wcb~ rules.  Variant tests should not be registered directly via ~bld()~ as this will circumvent the test suppression.

#+begin_src python
  with bld.smplpkg('MyPackage', ...) as p:
      p.rule("${WCSONNET} > ${TGT} 2>&1", target="wcsonnet-help.log")
#+end_src

The ~${WCSONNET}~ variable will point to the ~wcsonnet~ program in the build output.

Other helper functions include: FIXME.

* BATS

One interpreted test format is that of the Bash automated testing system ([[https://bats-core.readthedocs.io/][BATS]]).  This unit test framework allows one to quickly write simple bash functions to perform tests.  One may write atomic or variant tests as BATS files.  

Consider using BATS when you have many independent but related tests and/or wish to express the test as shell commands.  Aggregating many tests in a single BATS file will also help keep the ~wcb~ build DAG small and faster running.

WCT provides a copy of bats which will be found by ~wcb~.  If you wish to run bats directly you may find it convenient to set an alias:

#+begin_example
  $ alias bats=/path/to/my/wire-cell-toolkit/test/bats/bin/bats
#+end_example

Note, the ~bats-core~ package is still under development and the version of ~bats~ that may come with your OS may be too old.  Thus, this copy provided by WCT is preferred.

WCT provides a BATS support library ~test/wct-bats.sh~ to assist in writing BATS tests for WCT.  It is used like:

#+begin_example
  $ cat util/test/test_bats.bats
  #!/usr/bin/env bats
  
  load "../../test/wct-bats.sh"
  
  @test "test wct bats" {
      usepkg util apps
      t=$(top)
      [ -f "$t/build/apps/wire-cell" ] 
      [ -n "$util_src" ]
      [ -n "$(wcsonnet)" ] 
  }
  
  @test "dump env" {
      wcb dumpenv 1>&3
  }
#+end_example

The ~test/wct-bats.sh~ file is heavily commented and it is best to read this file to learn what functions it provides.  Additional guidance is in the document [[docs/bats.org][Guidance on writing BATS tests for WCT]].

In principle, a BATS test can be run directly from anywhere:

#+begin_example
bats util/test/test_bats.bats
#+end_example

However, some tests may not be written to be fully portable (the test has a bug!).  To fully replaced how ~wcb~ runs the test:

#+begin_example
cd build/
bats ../util/test/test_bats.bats
#+end_example

When run by default, all ~@test~ functions in a BATS file will be run and they are not idempotent (but Waf tests are).  Especially while developing tests i tis useful to narrow which are run by applying a filter on the strings given to the ~@test~ command.

#+begin_example
bats -f "test wct bats" util/test/test_bats.bats.
#+end_example

** Other unit test frameworks

In the future, support for ~pytest~ may be added.

* Writing atomic tests in C++

An atomic test, ~<pkg>/test/test_*.cxx~ 

- must not *require* any arguments including input/output file names
- may create files as a side effect
- should create those based on the name of the executable from ~argv[0]~.
- may load files via the environment (eg "wires files")
- should ~assert()~ and ~return 1~ (or any non-zero) for anything that goes wrong
- such assertions should be numerous
- may use WCT ~Testing.h~ helper

Here is a quick sampling to get started.  

#+begin_src c++
  #include "WireCellUtil/Testing.h"
  #include <ofstream>
  
  int main(int argc, char* argv[]) {
      std::string arg0 = argv[0];
      std::ofstream ofstr(arg0 + "_someout.ext");
      ofstr << "goodbye world!\n";
      if (do_something() != 42) return 1;
      assert(do_something_else());
      Assert(yet_more());
      AssertMsg(yet_more(), "with an error message");
      return 0;
  }
#+end_src  

* Writing a sub-DAG of variant tests

Though one has to write Waf code to register them, variant tests may be extended over a subgraph of the Waf DAG by connecting them with files.  See ~wire-cell-toolkit/util/wscript_build~ for various examples.

