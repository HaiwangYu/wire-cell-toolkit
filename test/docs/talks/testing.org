#+title: Wire-Cell Toolkit Testing System
#+setupfile: ../../../docs/setup-beamer.org

* Topics

\Large

- Quickstart
- The WCT testing system.
- Write WCT tests in C++.
- Write WCT tests in Bash.
- The WCT test data repository and historical tests.

* Quickstart: 80% of WCT testing

C++
- Make a C++ file: ~<pkg>/test/test_<mytest>.cxx~
- Return nonzero from ~main()~ on error (or call ~abort/assert/throw~). 
- Build+run a test ~./wcb --tests --target=test_<mytest>~ \\
  or run directly:  ~./build/<pkg>/test_<mytest>~

Bash
- Make a BATS (bash) file: ~<pkg>/test/test_<mytest>.bats~
- Define special bash functions holding tests: ~@test "test the thing" {...}~ 
- Run via build: ~./wcb --tests --target=test_<mytest>_bats~ \\
  or run directly: ~bats <pkg>/test/test_<mytest>.bats~

Build and run all tests: ~./wcb --tests~

* 

\Huge

#+begin_center
Now, the remaining 80%....
#+end_center


* WCT Testing System Overview

WCT testing system is layered.  It has test:

- code :: blocks of code that assert that some assumption is met.
- programs :: a ~main()~ with test code and that exits with error status when any test fails.
- groups :: a set of test programs run together.
- suite :: all tests can be run automatically.


* 



#+begin_center
\Huge Use \textbf{exceptions} to test code.

\normalsize (and other reasons)
#+end_center

* Low level testing: WCT C++ exceptions

It is okay for WCT library code to throw C++ exceptions.  

#+begin_src c++
  #include "WireCellUtil/Exceptions.h"
  //...
  if (is_bad(something)) {
      THROW(ValueError() << errmsg{"given something bad"});
  }
#+end_src
Note,
- We use ~THROW()~, a wrapper around C++'s ~throw~.
  - Uses ~boost~ exceptions, adds traceback reporting and other features.
- WCT defines a small set of "standard" exceptions....

* WCT exception types

~#include "WireCellUtil/Exceptions.h"~

\vfill

WCT defines exceptions that mimic Python's built-in exceptions:



- ~ValueError~ some value is found to be outside its expected domain.
- ~IndexError~ is a specific form of ~ValueError~ for when value is used for indexing.
- ~KeyError~ is a specific form of ~ValueError~ for when value is used for mapping.
- ~IOError~ is thrown when there is an error with an external resource (file, network).
- ~RuntimeError~ is use when no other exception fits.  



~ValueError~ is probably the most common to use.

Only use ~RuntimeError~ when others truly do not apply.

* When to throw an exception

- In ~configure()~, exhaustively check configuration and ~throw~ "liberally".
  - We want truly badly configured jobs to abort early.
  - Okay to coerce "bad" values to "good" values where reasonable. 

- Generally, prefer throwing exception over returning an "error value".
  - If must return error, use ~[[nodiscard]]~ to force user to handle.

- Whenever code has a "this can never happen" branch, it should throw.

- Avoid ~assert()~ in library code, but it is okay in test programs.
 

* When to catch an exception

- Always catch exceptions that your code can handle.

- Never catch exceptions that your code can not handle.

- Sometimes \textbf{catch and rethrow} to add value or reinterpret exception type.

Example C++ exception handling pattern:
#+begin_src c++
  SomeType val;
  try {
      val = code_that_may_throw();
  } catch (ExceptionType& err) {
      val = get_useful_default();
  }
  use_value(val);
#+end_src

* 

The reality is that most applications using WCT will "handle"
exceptions by aborting the process.

\vfill

WCT provides \textbf{no strategy} to continue the data-flow graph when
an exception "escapes" a node's execution.  (likewise /art/'s event loop).

* 

\Huge
#+begin_center
Use \textbf{test programs} for external assertions on software behavior and as\\
\textbf{software development drivers}.
#+end_center

* WCT test programs

Any program is a WCT test program if:

- It \textbf{requires no} command line arguments.
  - It may accept \textbf{optional} command line arguments.
- It returns \textbf{nonzero error status code} from ~main()~ if a test fails and \textbf{zero on success}.
- It is written in a supported language (C++, BATS / bash shell, Jsonnet, Python).
- It follows WCT \textbf{test group source file naming} convention.
- It neither consumes nor produces files that are tracked as build dependencies.
  - It may consume/produce untracked files and consume files implicitly available from the build.

Simple as this is, WCT provides support for \textbf{testing frameworks} which testing even simpler.

* WCT test groups

WCT test programs are organized into \textbf{test groups} with unique purposes:

- All tests in one group are executed together (possibly in parallel) by the build system.

- Each group is executed serially, in the order of the groups listed below.

- The group name (or optional alias) defines allowed \textbf{source file name prefix}.

Groups (in execution order):

- check :: build system will only compile and not (directly) execute.
- atomic :: basic tests that do not depend on the execution of any other test.  
- history :: produce and save out files to the \textbf{test data repository} for future use.
- report :: produce summary material for human inspection.


Notes:
- The test source file name prefix ``\textbf{test}'' may also be used for \textbf{atomic} tests.
- Each group may consume files or use programs from a prior group.

* WCT test program source

A test program source file name must match this pattern:

#+begin_center
~<pkg>/test/<prefix><sep><name>.<ext>~
#+end_center



- ~<pkg>~ names the sub package directory name, eg ~util~.
- ~<prefix>~ names the test /group/ or an alias for a group,
  - ~test~, ~atomic~, ~history~ etc.
- ~<sep>~ cosmetic, optional separator, may be an underscore ("~_~") or hyphen ("=~=").
- ~<name>~ brief, unique name to describe the assertion that is tested.
- ~<ext>~ defines how the test should be dispatched (compiled or interpreted).
  - Supported exentions: ~.cxx~, ~.bats~, ~.jsonnet~, ~.py~, ~.sh~ and ~.kokkos~.
  - We will focus only on C++ and bash/BATS in later slides.
  
* 

\Huge

#+begin_center
Run \textbf{test suites} with the WCT build system.
#+end_center

* Running WCT tests


\scriptsize
#+begin_example
./wcb --tests                        # build and run all tests not already run
./wcb --tests --alltests             # force also to re-run those already run
./wcb --tests list | less            # find available targets, including tests
./wcb --tests --target=test_testing  # run a specific test
                                     # force re-run specific test:
./wcb --tests --target=test_testing --alltests

./build/util/test/test_testing       # run compiled test
bats test/test/test_bats.bats        # run interpreted test

./build/util/test_testing foo bar    # give optional args
#+end_example

\normalsize

- WCT \textbf{tests are no longer built nor run by default}, need ~--tests~.
- When using using ~./wcb~, tests are only run once unless ~--alltests~ are given.
- Can also run compiled or interpreted tests directly.
- An "atomic" test can also accept optional command line arguments.
  - These have been named "variant tests"....


* Aside: atomic vs variant tests

- WCT tests \textbf{shall not require} command line arguments (atomic).
- WCT tests \textbf{may accept fully optional} arguments (variant).

Variant tests can be useful to re-use testing code for novel tests
that expand testing coverage.

Atomic tests can be made from variant tests by "baking" command line options into an atomic test script:

\scriptsize
#+begin_example
./build/aux/test_idft                     # called atomically, actually a variant
./build/aux/test_idft FftwDFT WireCellAux # these are the default arguments

./build/aux/test_idft cuFftDFT WireCellCuda
cuda/test/test_idft_cufftdft.bats         # bakes args for CUDA, lives in cuda/

./build/aux/test_idft TorchDFT WireCellPytorch
pytorch/test/test_idft_torchdft.bats      # etc for PyTorch
#+end_example  

More on BATS tests later.

* 

\LARGE

#+begin_center
Use \textbf{compiled tests} to test library code units.
#+end_center


* C++ tests

The basic WCT rules are already stated.
- If you want to DIY, those are all you need to care about.

WCT provides additional, optional support to make writing C++ tests easier.

- C++ helper code in ~libWireCellUtil~.

- Provision of and support for the ~doctest~ C++ testing framework.

* Testing helpers from WCT "util" library

Some ~#include "WireCellUtil/*.h"~ headers:

- ~Testing.h~ provides ~Assert(bool)~ and ~AssertMsg(bool,string)~
- ~TimeKeeper.h~ provides a "stopwatch" for lapped timing.
- ~MemUsage~ provides ways to track memory usage.

* WCT C++ testing framework: doctest

** What is a C++ testing framework?

- Easily form test code \textbf{contexts} (/ie/ functions).
- Ways to \textbf{assert variables hold expected values}.
- Assemble tests into executable programs.
- A variety of means to run tests individually and en masse.

** Why doctest

- Simple for user/developer and provides many helpers.
- Fast, low overhead runtime.
- Easy build integration: single header file.


* 

#+begin_center
\Huge Mini-tutorial on doctest
#+end_center


* doctest - build and run

#+begin_example
./wcb --target=wcdoctest-util   # build (and run)
wcdoctest-util                  # run all tests
wcdoctest-util -ltc             # list available test cases
                                # run a specific test case
wcdoctest-util --test-case="test some pca methods"
wcdoctest-util -d               # include duration timing
wcdoctest-util -h               # help for the many options
#+end_example

* doctest - source file

** Location

#+begin_example
wire-cell-toolkit/<pkg>/test/doctest_<name>.cxx
#+end_example

** How to pick ~<pkg>~

- Use the package holding the code you want to test.

- Use a package providing dependencies needed for the test.

** See also

WCT dependency graph: \scriptsize

https://github.com/WireCell/wire-cell-toolkit/blob/master/wct-deps.png

* doctest - file boilerplate

** Header file

#+begin_example
#include "WireCellUtil/doctest.h"
#+end_example

** That's it

- This is simply a copy of upstream ~doctest.h~ header.
- Of course, ~#include~ more depending on code you call.

* doctest - test case boilerplate

** Provide a name for a test context

#+begin_example
TEST_CASE("my first test") {
    // body of the test with assertions
}
#+end_example

** Notes

- The ~TEST_CASE()~ is a CPP macro but think of it as a function.
- Its name can be used to select the test with the command line program.

* doctest - assertions

** A test is asserting an expected value

#+begin_example
WARN(today == "weekend");      // only print a warning if false
CHECK(1 + 1 == 2);             // does not halt testing
REQUIRE(false == true);        // halts testing
CHECK_EQ( 1 + 1, 2 );
CHECK_FALSE( 1 + 1 = 3 );
CHECK(3.14 == doctest::Approx(22.0/7).epsilon(0.01));
CHECK_MESSAGE(x == 42, "do not know the answer");
REQUIRE(version == doctest::Contains("0."));
CHECK_THROWS_AS(func(), ValueError);
#+end_example

** Notes

See more in doctest's [[https://github.com/doctest/doctest/blob/master/doc/markdown/assertions.md][assertions doc]].

* doctest - logging

** doctest built-in

#+begin_example
INFO("A message string ", 42, " ", stringifiable_object);
CAPTURE(some_variable);  // INFO() with var name + value
WARN(false);             // will cause above to output to log
FAIL("this wil abort");  // also triggers log output
#+end_example

** Notes
- Logging is output only if an assertion fails (including a ~WARN()~).
- Stringification is lazy, will log value at time of failed assertion.
  - More details in [[https://github.com/doctest/doctest/blob/master/doc/markdown/logging.md][doctest logging doc]].
- To see WCT/spdlog messages, set env. var. ~SPDLOG_LEVEL=debug~.

* doctest - subcase

** A subcase is a new, unique code context/scope

\scriptsize
#+begin_example
TEST_CASE("my first test") {
    bool ok=true;
    SUBCASE("a test using above as existing context") {
        ok = false;
        CHECK(!ok);
    }
    SUBCASE("another test using copy of the context") {
        // subcase above does not change our 'ok' variable
        CHECK(ok);
    }
}
#+end_example

** Notes
\footnotesize
- Changing an outer value (/eg/ ~ok~) in one ~SUBCASE()~ does not affect the value in another ~SUBCASE()~.
- Can nest ~SUBCASE()~'s.   More info in doctest's [[https://github.com/doctest/doctest/blob/master/doc/markdown/testcases.md][test cases doc]].

* doctest - expert level

- [[https://github.com/doctest/doctest/blob/master/doc/markdown/testcases.md#test-fixtures][Test fixtures]] are user-provided base classes that a test inherits.
- [[https://github.com/doctest/doctest/blob/master/doc/markdown/testcases.md#test-suites][Test suites]] allow running a subset of tests via a filter.
- [[https://github.com/doctest/doctest/blob/master/doc/markdown/testcases.md#decorators][Test decorators]] set attributes such as skipping, failure expectations, run time limits.

* 

#+begin_center
\Huge Intermission... 
#+end_center


* 

\LARGE

#+begin_center
Use BATS tests for \textbf{interpreted shell script tests} for testing at "job" level and for driving code development.
#+end_center

* BATS in WCT

BATS = Bash Automated Testing System

- WCT adopts and provides support for [[https://bats-core.readthedocs.io][BATS]] to write tests as shell scripts.

- A BATS file is a bash shell script with special function signatures: \\
  ~@test "test description" {...test body...}~.
- Source file matches ~<pkg>/test/<prefix><sep><name>.bats~.
- All BATS tests are \textbf{atomic} by design.
- BATS provides shell function "helpers", WCT augments with ~wct-bats.sh~ BATS library.
- WCT provides a recent copy of BATS, used automatically by ~wcb~ build or user may DIY:
#+begin_example
PATH=/path/to/wire-cell-toolkit/test/bats/bin:$PATH
export BATS_LIB_PATH=/path/to/wire-cell-toolkit/test
#+end_example  
  

* BATS file skeleton 

#+begin_example
#!/usr/bin/env bats
bats_load_library wct-bats.sh     # WCT support library
setup_file () {
  # optional, one time initialization
}
@test "describe the assertion tested" {
  # bash shell code with tests that may fail....
}
@test "can have multiple tests" {
  # any command that fails, fails the test
  /bin/false
}
teardown_file () {
  # optional, one time finalization
}
#+end_example

* BATS basic test

#+begin_example
@test "run something" {
  run wire-cell --help                                   # 1
  echo $output                                           # 2
  [[ "$status" -eq 0 ]]                                  # 3
  [[ -n "$(echo $output | grep 'Wire-Cell Toolkit')" ]]  # 4
}
#+end_example

1. The ~run~ command is a BATS helper, sets ~$status~ and ~$output~ from command result.
2. Any free ~echo~ will only print to screen if any subsequent commands fail.
  - Or if using: ~bats --show-output-of-passing-tests [...]~
3. Assure zero ~$status~ code (ie, success).
4. Assure some expected string is found in ~$output~.

* WCT/BATS basic test

The WCT/BATS library provides simple functions for common operations.

#+begin_example
bats_load_library wct-bats.sh

@test "run something" {
  wct --help                                            # 1,2,3
  [[ -n "$(echo $output | grep 'Wire-Cell Toolkit')" ]] # 4
}
#+end_example

The ~wct~ command calls ~wire-cell~ for us and includes echoing ~$output~ and testing ~$status~.

* Leveraging BATS for driving software development

Developers should \textbf{start} with a BATS test and fill it in as they develop new features.

WCT/BATS makes this easier than writing DIY development drivers/tests.

- Capture what you are doing and what you did in a consistent and communicative way.
- If/when a bug is found, it automatically has a test.
- Can use ~setup_file()~ to run a "main job" and many fast ~@test~'s to check different facets of its output.
- Use ~bats --filter "pattern" <pkg>/test/test_<name>.bats~ to focus your attention. Filtered tests still run ~setup_file()~. 
- Speed up long running commands with \textbf{idempotent} running.
  - Only re-run jobs based on input/output file age.
- Practice "test driven development" paradigm, if you wish.

* BATS filtering to exercise focus

Here is a BATS test file  with many test cases.  We can focus on one:

#+begin_example
  $ grep -c '@test' test/test/test-pdsp-simsn-nfsp.bats
  12

  $ bats test/test/test-pdsp-simsn-nfsp.bats
  # --> runs all 12 tests

  $ bats -f "no threshold" test/test/test-pdsp-simsn-nfsp.bats
  # --> runs just the one matching test
#+end_example

* Idempotency in BATS

#+begin_quote
A function execution is idempotent if subsequent execution leaves state unchanged.
#+end_quote

Idempotency lets us sometimes safely skip re-execution and save time (simple/mini build system).

\vfill

WCT/BATS provides ~run_idempotently~ which takes source and target files and
a command and will run the command only if sources are newer than
targets or targets do not exist.

#+begin_example
bats_load_library wct-bats.sh
setup_file() {
  # ... define variables pointing to files ...
  run_idempotently -s $dag_file -t $adc_file -t $log_file -- \
                     wct -l $log_file -L debug -c $dag_file
}
#+end_example

But, to really use this we need to understand how BATS uses temporary directories....

* BATS temporary directories

A temporary directory is made for each of BATS \textbf{runs, files} and \textbf{tests}.
- BATS code does \textbf{not} ~cd~ to the temporary directory by default.
- WCT/BATS provides ~cd_tmp [<context>]~ function to do that.

#+begin_example
setup_file () {
  cd_tmp          # cd to the "file-context" temp dir
  # ...
}
@test "some test" {
  cd_tmp          # cd to the "test-context" temp dir
  # ...
  cd_tmp file     # cd explicitly to "file-context"
  # ...
}
#+end_example

* Keeping BATS temporary directories

Retain BATS' temporary, but randomly generated directories:
#+begin_example
$ bats --no-tempdir-cleanup test/test/test_bats.bats
# ...tests run and finally prints:
BATS_RUN_TMPDIR: /tmp/bats-run-V5XpTD
$ rm -r /tmp/bats-run-V5XpTD
#+end_example

Pre-defining temporary directories for ~cd_tmp~:
#+begin_example
$ WCTEST_TMPDIR=$(pwd)/tmp bats test/test/test_bats.bats
$ rm -r tmp
#+end_example
Note: it is only when using a fixed ~WCTEST_TMPDIR~ that ~run_idempotently~ will actually run idempotently!

* A sampling of WCT BATS functions

- ~wct~ runs the ~wire-cell~ command, ~wcb~ runs the Wire-Cell build command, \\
   ~version~ gives WCT version string.
- ~compile_jsonnet~, ~dotify_graph~ work with WCT config files.
- ~file_larger_than~ tests that a file has at least some amount of data.
- ~topdir~, ~blddir~, ~srcdir path~, ~relative_dir path~, finds paths in source.
- ~usepkg <pkg>~, add ~build/<pkg>~ into ~PATH~ and define ~$<pkg>_src~ pointing to source directory.
- ~wcb_env~ set all Waf environment variables as shell environment variables.
- ~wcb_env_value <varname>~ echo the Waf environment variable value.
  - Run ~./wcb dumpenv~ to see what Waf variables are defined.
  - ~WCxxx~ points to ~wirecell-xxx~ programs from ~wire-cell-python~, if available.

* The WCT test data repository

Most files produced by tests are ephemeral in BATS temporary directories.

But, tests can "save out" files to the \textbf{WCT test data repository} located at:

#+begin_example
build/tests/input/<dirs>/<files>
build/tests/<category>/<version>/<test-name>/<files>
#+end_example

- The ~/input/~ area holds data files consumed by but not, in general, produced by tests.
- The ~/<category>/~ names intention, eg \textbf{plots}, \textbf{history}, \textbf{reports}.
- The ~<version>~ is that of the software producing the files (Waf variable ~VERSION~).
- ~./wcb packrepo~ packs repo to tar files.  ~./wcb --tests~ installs them.
  - for now, remote repo lives [[https://www.phy.bnl.gov/~bviren/tmp/wcttest/data_repo/][here]] and is manually populated from repo packs.

* Saving files to test data repo from BATS

\textbf{The repo is not a dumping ground!}

Only "save out" files with clear intention how they will be used longer term.

A "save out" is done with WCT's ~wct-bats.sh~ library function ~saveout~:

#+begin_example
@test "some history test" {
  # make somefile.npz here....
  saveout -c history somefile.npz
}
@test "some plotting test" {
  # make someplot.png here....
  saveout -c plots someplot.png
}
#+end_example

* Using BATS tags

BATS supports placing "tags" on tests in comments and WCT uses them:

\scriptsize
#+begin_example
  # bats test_tags=history
  @test "make history" {
    # ...
    saveout -c history my-file-for-history.npz
  }
  $ bats --filter-tags history [...]
#+end_example

\normalsize

Some reserved WCT tags:

- ~history~ :: the test produces official "history" files for the data repo.
- ~report~ :: the test produces a "report" of files saved to output.
- ~implicit~ :: the test only performs weak, implicit tests ("it ran and didn't crash").
- ~issue:<number>~ :: The test is relevant to GitHub issue of the given number.
- ~pkg:<name>~ :: The test is part of package named ~<name>~ (~gen~, ~util~, etc)
- ~topic:<name>~ :: The test relates to topic named ~<name>~ (~wires~, ~response~, etc)

* (Re)Making history

New tests are invented and we want to run them against old WCT software.

#+begin_example
./test/scripts/multi-release-testing \
   ~/wct/releases/rel{21,22,23,24} \
   ~/wct/development/master ~/wct/development/0.24.x
#+end_example

- Runs tests and place all ~saveout~ results in the \textbf{current release area}.
- Runs tests in 4 named releases, 2 development areas, \textbf{per-release parallelism}.
- Requires an ~.envrc~ file exists and manages each areas environment.
- Runs only the tests with a tag of ~history~.

Caveats:
- Some code may be simply too old to run some new tests.
  - We define suitable old versions in Waf env var ~TEST_DATA_VERSIONS~.
- Requires software release environment managed with [[https://direnv.net/][direnv]].




* Further documentation of WCT testing system

WCT testing has comprehensive documentation:

- Main entry point on github 

https://github.com/WireCell/wire-cell-toolkit/blob/master/test/README.org

- Nicely rendered version (may be out of date from GitHub):

https://wirecell.bnl.gov/test/README.html

- Of course, existing tests provide wealth of examples:

#+begin_example
$ ls */test/{atomic,test}*.cxx|wc -l
199
$ ls */test/test*.bats|wc -l
17
$ ls */test/doctest*.cxx | wc -l
4
#+end_example

* 

\Huge

\[ \mathcal{FIN} \]

* Backups slides

* What is software testing?

\Large
#+begin_quote
Executing the software in a way that asserts expected behavior.
#+end_quote

* What is testing software?

- A "test" is software that exercises the software under test.

- A "test" must *assert* expected behavior.
  - It must be possible to fail or it is not a test. 

- A "test" must require no special knowledge to run.

- A "test" may be defined on a \textbf{spectrum} of code scale:

  - a code fragment inside the software,

  - a single program exercising the software,

  - multiple, inter-dependent programs,

  - a "suite" consisting of many of the above.


* What is a testing framework?

\Large
#+begin_quote
Guidelines, rules and/or additional software that are used in
developing and executing tests in a consistent and flexible manner.
#+end_quote

\normalsize
\vfill
WCT provides a testing system that hits on all these qualities.


* Categories of testing


\scriptsize
-    Acceptance :: Verifying whether the whole system works as intended.
-    Integration :: Ensuring that software components or functions operate together.
-    Unit testing: Validating that each software unit performs as expected. A unit is the smallest testable component of an application.
-    Functional :: Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions.
-    Performance :: Testing how the software performs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions.
-    Regression :: Checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions and commands at the surface level, when there is no time for a full regression test.
-    Stress :: Testing how much strain the system can take before it fails. Considered to be a type of non-functional testing.
-    Usability :: Validating how well a customer can use a system or web application to complete a task.

Cribbed from https://www.ibm.com/topics/software-testing


# Local Variables:
# eval: (fix-latex-previews)
# End:
