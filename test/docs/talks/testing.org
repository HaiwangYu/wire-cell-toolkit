#+title: Wire-Cell Toolkit Testing System
#+setupfile: ../../../docs/setup-beamer.org

* Topics                                                                :new:

\Large

- Motiviation
  - /ad-hoc/ testing /vs/ a testing system
- Quickstart
- The WCT testing system.
- Write WCT tests in C++.
  - C++ exceptions
- Write WCT tests in Bash.
- The WCT test data repository and historical tests.

* Motivation                                                            :motivation:

#+begin_quote
\LARGE We all believe we must test our software.
#+end_quote

Right?

\vfill

But, what does that mean?

- Ad-hoc testing /vs/ a "testing system".

- Why (and how) should I use a "testing system"?

* Ad-hoc testing                                                        :motivation:

We often invent our own /ad-hoc/ testing "systems" with these characteristics:

- Develop expert ~main()~ programs with complex command line arguments or inputs.
- Write simple or complicated shell scripts that only work on our computer.
- Keep our tests "secret" and/or difficult for others to use (perhaps unintentionally).
- Release buggy code and let our users be the testers.
- Fix the bug of the moment, unknowingly add new bugs, delete our /ad-hoc/ tests.

* Why a testing "system"                                                :motivation:


#+begin_center
\Huge Enforce desired developer behavior

\normalsize (and make that easy and enjoyable)
#+end_center


* Goals of a testing system                                             :motivation:

We want a testing system that:
- Does not require expert knowledge to run the tests.
- Allows tests to be easily exercised by all developers and users.
- Automate the running of test code during development and for releases.
- Enables precise communication of issues found by users and between developers.
- Helps us fix a bug exactly once (no regressions).
- Provides a common "language" in which we may discuss testing itself.
- Allows tests to compare results between software versions.
- Allows human inspection of test results that do not fit into a simple pass/fail paradigm.
- Enables code refactoring while retaining expectations.
- \textbf{Helps} developers do their thing.

* WCT Testing System Overview                                           :overview:

We may provide testing code at different "scales" or "levels".  From low to high:

- library :: checks that may throw \textbf{exceptions} in our libraries.
- unit :: concise checks and assertions outside of our libraries. 
- programs :: a full C++ ~main()~ or a script.
- groups :: a set of test programs run together for a particular testing goal.
- suite :: all tests can be run automatically.

* What testing scale is right for me?

Two answers: "all of them" and "it depends".

\vfill

- To develop library code: \textbf{use exceptions}.
- To test individual functions or maybe a whole class: \textbf{use unit tests}.
- To test many classes together: \textbf{use test program}.
- To produce history data, plots and reports: \textbf{use test groups}.
- To make releases or just test everything: \textbf{use test suite}.

\vfill

The rest of this presentation gives a lot of detail about each. 

* Exceptions for library-level testing                           :exceptions:

#+begin_center
\Huge Use \textbf{exceptions} to test code right inside our libraries.
#+end_center

* What are C++ exceptions                                               :exceptions:

- A C++ \textbf{exception} is an instance of a type (usually a ~class~).

- A called function may (or may not) \textbf{throw} an exception to signal that an error has occurred.

- Any caller may \textbf{catch} an exception \textbf{by its type} in order to handle the error.


* The life cycle of an exception                                 :exceptions:

- Some running code \textbf{throws} an exception of some \textbf{type}.
- A search for a \textbf{type-matched catch} begins.
  - Start from the initial code context, then traverse the \textbf{call stack} toward ~main()~.
- If a match is found continue execution from the \textbf{catch code block}.
- If no match is found, process \textbf{exits with error status code}.


* Why are exceptions good (compared to returning "error" values)? :exceptions:

- Exceptions \textbf{can not be ignored}, return values are often ignored.
  - C++ provides ~[[nodiscard]]~ which helps to not ignore return values.
- Exceptions \textbf{imply meaning} through their type.
  - Return values require inventing /ad-hoc/ interpretations for good/bad values.
  - ~main()~ must return ~int~, always follow Unix standard: \textbf{zero is success}, non-zero is error.
- Exceptions \textbf{carry human-oriented messages} through their ~what()~ string
  - WCT exceptions add \textbf{traceback} information.
- Direct caller may not be able to handle error, but a (grand)parent caller may.
  - With return value we must complicate all code with "error forwarding".

* Why are exceptions bad (they are not)                                 :exceptions:

Exceptions are slow!
- No: modern compilers add essentially no overhead when supporting exceptions.
- Okay, a ~throw~ is marginally slower than a ~return~ but it is called ... \textbf{exceptionally}.

Exceptions cause programs to crash!
- Good: better to halt a program than to ignore return error codes or allow ~segfault~, etc.
- Good: helps developers find ignored errors quickly.

Exceptions are hard to program!
- Meh: a ~throw~ is slightly more code than a ~return~.
- Meh: a ~catch~ is slightly more than an ~if() {}~ check on a return value.

* When to throw an exception                                            :exceptions:

#+begin_quote
Throw an exception anytime an assumption is found to be violated.
#+end_quote

** Assumptions are ultimately specification of a data domain

- A function argument passes a value that outside an allowed/expected range.

- A return value is formed that is outside of the function range.

- An intermediate value is formed which for which the code can not further process.

- A configuration object is missing an expected attribute or has the wrong type of value.

- A file that is being parsed violates the expected schema.

- An inconsistency in code logic is encountered.
  
** But, sometimes we may "fix" a bad value instead of throwing an exception

- Can we cast? ~float x = cfg.asFloat(cfg["given_an_int"])~
- Can we coerce? ~std::clamp(val,lo,hi)~?

* What type of exception to throw                                       :exceptions:

WCT defines a small subset similar to standard C++/Python exception types.
\vfill

~#include "WireCellUtil/Exceptions.h"~

\vfill

- ~ValueError~ when a value is found to be outside its expected domain (\textbf{most common!}).
  - ~IndexError~ the domain is that of some lookup index.
  - ~KeyError~ the domain is that of some lookup key.
- ~RuntimeError~ due to external events and/or hard to reproduce.
- ~LogicError~ local preconditions or internal assumptions violated.
- ~IOError~ error with an external resource (file, network).

* How to throw an exception                                             :exceptions:

** Standard way

Can use C++ ~throw~ keyword, but better info when using WCT helpers.

** Old way - a little verbose

#+begin_example
  THROW(ValueError() << errmsg{"some message and " + a_string});
#+end_example

** New way - more succinct with ~printf()~ format codes

#+begin_example
  raise<ValueError>("some message and %s", a_string);
#+end_example


\footnotesize
- This is a new feature first in the ~apply-pointcloud~ branch.
- Mistakes with format codes will themselves throw exceptions. 

* When to catch an exception                                            :exceptions:

- \textbf{Always catch} an exception that your code \textbf{can handle}.

- \textbf{Never catch} an exception that your code \textbf{can not handle}.


\vfill
Some rare, special cases:
- May \textbf{catch and rethrow} to log info from the calling context but otherwise not handle.
- Convert exception (or return value) types at API boundaries.



* How to catch an exception

#+begin_example
try {  function_that_may_throw(); }
catch (const KeyError& e)   { handle_key_error(); }
catch (const IndexError& e) { handle_index_error(); }
catch (const Exception& e)  { handle_base_error(); }
catch (...)                 { handle_unknown_error(); }
#+end_example

* Exception code example                                                :exceptions:

\footnotesize
#+begin_src c++
  void do_something(const std::string& something) {
      if (is_bad(something)) {
          THROW(ValueError() << errmsg{"given something bad"});
      }
  }
  void func(size_t index) {
      auto thing = translate_command(index);
      do_something(thing);
  }
  void another_func() {
      size_t index = calculate_index();
      try {
          func(index);
      }
      catch (const ValueError& err) {
          std::cerr << "I did a bad thing\n";
      }
  }
#+end_src


* Unit tests

\Huge
#+begin_center
Use \textbf{unit tests} for brief, focused assertions.
#+end_center

* What are unit tests and unit test frameworks

** Unit test

A test of a small chunk (unit) of library code with a small chunk of test code.

** Unit test framework

A way to develop unit tests in an organized way that allows fast, comprehensive and/or targeted running.

* WCT supports two types of unit tests

** doctest

- Provides ~main()~ and many useful CPP macros.
- Defines how to write tests, limiting but simplifying.
- Best for writing many, small tests.

** programs

- User provides the entire ~main()~ following some conventions.
- Largely unconstrained, user-provided ~main()~
- Good for larger, single-test programs.
- Coarse-grained inter-group file sharing (more on this later).

** Common

All tests may be built and run by WCT build system.


* 

#+begin_center
\Huge Mini-tutorial on doctest
#+end_center




* doctest - introduction

With [[https://github.com/doctest/doctest][doctest]]:

- we easily write many little tests in one or more C++ files.
- all tests from each package are built into a single program.
- we may execute all tests or individual tests in isolation.

* doctest - source file

** Location

#+begin_example
wire-cell-toolkit/<pkg>/test/doctest_<name>.cxx
#+end_example

** How to pick ~<pkg>~

- Use the package holding the code you want to test.

- Use a package providing dependencies needed for the test.

** See also

WCT dependency graph: \scriptsize

https://github.com/WireCell/wire-cell-toolkit/blob/master/wct-deps.png

* doctest - file boilerplate

#+begin_example
#include "WireCellUtil/doctest.h"
#+end_example

\vfill

That's it!

- Of course, ~#include~ more depending on what code you call/test.

* doctest - test case boilerplate

** Provide a name for a test context

#+begin_example
TEST_CASE("my first test") {
    // body of the test with assertions
}
#+end_example

** Notes

- The ~TEST_CASE()~ calls a CPP macro but think of it as a function declaration.
- The name can be used to select the test with the command line program.

* doctest - assertions

** A test is asserting an expected value

#+begin_example
WARN(today == "weekend");      // only print a warning if false
CHECK(1 + 1 == 2);             // does not halt testing
REQUIRE(false == true);        // halts testing
CHECK_EQ( 1 + 1, 2 );
CHECK_FALSE( 1 + 1 = 3 );
CHECK(3.14 == doctest::Approx(22.0/7).epsilon(0.01));
CHECK_MESSAGE(x == 42, "do not know the answer");
REQUIRE(version == doctest::Contains("0."));
CHECK_THROWS_AS(func(), ValueError);
#+end_example

** Notes

See more in doctest's [[https://github.com/doctest/doctest/blob/master/doc/markdown/assertions.md][assertions doc]].

* doctest - logging

** doctest built-in

#+begin_example
INFO("A message string ", 42, " ", stringifiable_object);
CAPTURE(some_variable);  // INFO() with var name + value
WARN(false);             // will cause above to output to log
FAIL("this wil abort");  // also triggers log output
#+end_example

** Notes
- Logging is output only if an assertion fails (including a ~WARN()~).
- Stringification is lazy, will log value at time of failed assertion.
  - More details in [[https://github.com/doctest/doctest/blob/master/doc/markdown/logging.md][doctest logging doc]].
- To see WCT/spdlog messages, set env. var. ~SPDLOG_LEVEL=debug~.

* doctest - subcase

** A subcase is a new, unique code context/scope

\scriptsize
#+begin_example
TEST_CASE("my first test") {
    bool ok=true;
    SUBCASE("a test using above as existing context") {
        ok = false;
        CHECK(!ok);
    }
    SUBCASE("another test using copy of the context") {
        // subcase above does not change our 'ok' variable
        CHECK(ok);
    }
}
#+end_example

** Notes
\footnotesize
- Changing an outer value (/eg/ ~ok~) in one ~SUBCASE()~ does not affect the value in another ~SUBCASE()~.
- Can nest ~SUBCASE()~'s.   More info in doctest's [[https://github.com/doctest/doctest/blob/master/doc/markdown/testcases.md][test cases doc]].

* doctest - expert level

- [[https://github.com/doctest/doctest/blob/master/doc/markdown/testcases.md#test-fixtures][Test fixtures]] are user-provided base classes that a test inherits.
- [[https://github.com/doctest/doctest/blob/master/doc/markdown/testcases.md#test-suites][Test suites]] allow running a subset of tests via a filter.
- [[https://github.com/doctest/doctest/blob/master/doc/markdown/testcases.md#decorators][Test decorators]] set attributes such as skipping, failure expectations, run time limits.




* doctest - build and run

#+begin_example
./wcb --target=wcdoctest-util   # build (and run)
wcdoctest-util                  # run all tests
wcdoctest-util -ltc             # list available test cases
                                # run a specific test case
wcdoctest-util --test-case="test some pca methods"
wcdoctest-util -d               # include duration timing
wcdoctest-util -h               # help for the many options
#+end_example



* 

\Huge
#+begin_center
Use \textbf{test programs} for larger, single-test executables and/or to fit into \textbf{test groups}.
#+end_center

* WCT test programs

Any program is a WCT test program if:

- All command line arguments are \textbf{optional}.
- It returns \textbf{nonzero error status code} from ~main()~ if a test fails and \textbf{zero on success}.
- It is written in a supported language (C++, bash, others).
- It follows WCT \textbf{test group source file naming} convention.
- It neither consumes nor produces files that are tracked as build dependencies.
  - It may consume/produce untracked files and consume files implicitly available from the build.



* WCT test groups organize test programs for unique purposes

** Build system executes one group at a time in order:

- check :: build system will only compile and not (directly) execute.
- atomic :: basic tests that do not depend on the execution of any other test.  
- history :: produce and save out files to the \textbf{test data repository} for future use.
- report :: produce summary material for human inspection.

Inside group, test programs may execute in parallel.


** Notes:
- Group is determined by source file name (see next).
- Each group may consume files or use programs from a prior group.
- The ~wcdoctest-<pkg>~ programs are considered in the \textbf{atomic} group.



* WCT test program source filename pattern

#+begin_center
~<pkg>/test/<prefix><sep><name>.<ext>~
#+end_center

- ~<pkg>~ names the sub package directory name, eg ~util~.
- ~<prefix>~ names the test \textbf{group} or an alias for a group,
  - \textbf{test} is an alias for \textbf{atomic}
- ~<sep>~ cosmetic, optional separator, may be an underscore ("~_~") or hyphen ("=~=").
- ~<name>~ brief, unique name to describe the assertion that is tested.
- ~<ext>~ defines how the test should be dispatched (compiled or interpreted).
  - Supported exentions: ~.cxx~, ~.bats~, ~.jsonnet~, ~.py~, ~.sh~ and ~.kokkos~.
  - We will focus only on C++ and bash/BATS in later slides.
  
** Examples

~util/test/test_array.cxx~

~test/test/history-comp1d.bats~

* Aside: variant tests

- WCT tests \textbf{shall not require} command line arguments (atomic).
- WCT tests \textbf{may accept fully optional} arguments (variant).

Variant tests can be useful to re-use testing code for novel tests.

Atomic tests can be made from variant tests by "baking" command line options in a test script:

\scriptsize
#+begin_example
./build/aux/test_idft                     # called atomically, actually a variant
./build/aux/test_idft FftwDFT WireCellAux # these are the default arguments

./build/aux/test_idft cuFftDFT WireCellCuda
cuda/test/test_idft_cufftdft.bats         # bakes args for CUDA, lives in cuda/

./build/aux/test_idft TorchDFT WireCellPytorch
pytorch/test/test_idft_torchdft.bats      # etc for PyTorch
#+end_example  

More on BATS tests later.



* WCT C++ test programs

Not much to it
- Follow all the rules for any WCT test program (see above).
- Provide the entire ~main()~.



* Testing helpers from WCT "util" library

Some ~#include "WireCellUtil/*.h"~ headers:

- ~Testing.h~ provides ~Assert(bool)~ and ~AssertMsg(bool,string)~
- ~TimeKeeper.h~ provides a "stopwatch" for lapped timing.
- ~MemUsage~ provides ways to track memory usage.

* Aside: more and high-level helpers needed

A number of operations are tedious to "bootstrap" in C++ testing code

- Generate or load wires geometry.
- Make ~IAnodePlane~ for some detector.
- Call things handled by ~Main~ plugin loading, factory, configuration.
- Construct and execute small data-flow graph.

Want to take some time to develop "helpers" to reduce tedium.
- Some "helpers" are local in ~test/*.cxx~ but should move to libraries.
- Need some "canned" configuration so tests can simply ask:
  - Give me anodes for detector "XYZ".

* 

\Huge

#+begin_center
Use test programs as development drivers.
#+end_center

* Test programs as vehicles for development

We all naturally write some kind of /ad-hoc/ program when we develop software.

- Go the extra inch and make that a WCT test program.

- Need more than one test program, no problem, go for it.

- Want command line options?  That's okay! (see variants).

- Need to run many programs or post-process program output?  Great!
  Make a test script (see BATS coming up).

Start a WCT test program and
\textbf{commit it} before/during your next development.

Please, no more "private" test programs!

* 


\Huge

#+begin_center
Run \textbf{test suites} with the WCT build system.
#+end_center

* Running \textbf{all} or \textbf{some} WCT tests


\scriptsize
#+begin_example
./wcb --tests                        # build and run all tests not already run
./wcb --tests --alltests             # force also to re-run those already run
./wcb --tests list | less            # find available targets, including tests
./wcb --tests --target=test_testing  # run a specific test
                                     # force re-run specific test:
./wcb --tests --target=test_testing --alltests

./build/util/test/test_testing       # run compiled test
bats test/test/test_bats.bats        # run interpreted test

./build/util/test_testing foo bar    # variant test, give optional args
#+end_example

\normalsize

- WCT \textbf{tests are no longer built nor run by default}, need ~--tests~.
- When using using ~./wcb~, tests are only run once unless ~--alltests~ are given.
- Can also run compiled or interpreted tests directly.


* 

\LARGE

#+begin_center
Use BATS tests for \textbf{interpreted shell script tests} for testing at "job" level and/or for tests requiring multiple programs.
#+end_center

* BATS in WCT

BATS = Bash Automated Testing System

- WCT adopts and provides support for [[https://bats-core.readthedocs.io][BATS]] to write tests as shell scripts.

- A BATS file is a bash shell script with special function signatures: \\
  ~@test "test description" {...test body...}~.
- Source file matches ~<pkg>/test/<prefix><sep><name>.bats~.
- BATS tests do not take command line arguments.
- BATS provides shell function "helpers", WCT augments with ~wct-bats.sh~ BATS library.
- WCT provides a recent copy of BATS, used automatically by ~wcb~ but user may also DIY:
#+begin_example
PATH=/path/to/wire-cell-toolkit/test/bats/bin:$PATH
export BATS_LIB_PATH=/path/to/wire-cell-toolkit/test
#+end_example  
  

* Why write a BATS test

- You want to run external programs that can not be run from C++ test program or unit test.
- You want to run a ~wire-cell~ job and then test its results.
- You want to make and save plots or historical data to the \textbf{test data repository}.
- You want to run a chain of test programs which share data and can be rerun efficiently.

* How does a BATS test fit into WCT testing system

A BATS test file is "just" a WCT \textbf{test program}.

- No command line arguments.
- Follows the source file name convention.
- Participates in testing groups execution (atomic, history, report).

In addition, WCT provides some extra support:
- Integration with \textbf{test data repository}.
- Efficient re-running of idempotent steps.


* BATS file skeleton 

#+begin_example
#!/usr/bin/env bats
bats_load_library wct-bats.sh     # WCT support library
setup_file () {
  # optional, one time initialization
}
@test "describe the assertion tested" {
  # bash shell code with tests that may fail....
}
@test "can have multiple tests" {
  # any command that fails, fails the test
  /bin/false
}
teardown_file () {
  # optional, one time finalization
}
#+end_example

* BATS basic test

#+begin_example
@test "run something" {
  run wire-cell --help                                   # 1
  echo $output                                           # 2
  [[ "$status" -eq 0 ]]                                  # 3
  [[ -n "$(echo $output | grep 'Wire-Cell Toolkit')" ]]  # 4
}
#+end_example

1. The ~run~ command is a BATS helper, sets ~$status~ and ~$output~ from command result.
2. Any free ~echo~ will only print to screen if any subsequent commands fail.
  - Or if using: ~bats --show-output-of-passing-tests [...]~
3. Assure zero ~$status~ code (ie, success).
4. Assure some expected string is found in ~$output~.

* WCT/BATS basic test

The WCT/BATS library provides simple functions for common operations.

#+begin_example
bats_load_library wct-bats.sh

@test "run something" {
  wct --help                                            # 1,2,3
  [[ -n "$(echo $output | grep 'Wire-Cell Toolkit')" ]] # 4
}
#+end_example

The ~wct~ command calls ~wire-cell~ for us and includes echoing ~$output~ and testing ~$status~.

* Leveraging BATS for driving software development

Consider to \textbf{start} with a BATS test and fill it in as you develop library code.

WCT/BATS makes this easier than writing DIY development drivers/tests.

- Capture what you are doing and what you did in a consistent and communicative way.
- When a bug is found, you BATS script fails so you automatically have a test for the bug.
- Can use ~setup_file()~ to run a "main job" and many fast ~@test~'s to check different facets of its output.
- Use ~bats --filter "pattern" <pkg>/test/test_<name>.bats~ to focus your attention.
  - Filtered tests still run ~setup_file()~.
  - Make new ~@test~ for each development facet, run current tests for fast checks.
- Speed up long running commands with \textbf{idempotent} running.
  - Only re-run jobs based on input/output file age.
- Practice "test driven development" paradigm, if you wish.

* BATS filtering to exercise focus

Here is a BATS test file  with many test cases.  We can focus on one:

#+begin_example
  $ grep -c '@test' test/test/test-pdsp-simsn-nfsp.bats
  12

  $ bats test/test/test-pdsp-simsn-nfsp.bats
  # --> runs all 12 tests

  $ bats -f "no threshold" test/test/test-pdsp-simsn-nfsp.bats
  # --> runs just the one matching test
#+end_example

* Idempotency in BATS

#+begin_quote
A function execution is idempotent if subsequent execution leaves state unchanged.
#+end_quote

Idempotency lets us sometimes safely skip re-execution and save time (simple/mini build system).

\vfill

WCT/BATS provides ~run_idempotently~ which takes source and target files and
a command and will run the command only if sources are newer than
targets or targets do not exist.

#+begin_example
bats_load_library wct-bats.sh
setup_file() {
  # ... define variables pointing to files ...
  run_idempotently -s $dag_file -t $adc_file -t $log_file -- \
                     wct -l $log_file -L debug -c $dag_file
}
#+end_example

But, to really use this we need to understand how BATS uses temporary directories....

* BATS temporary directories

A temporary directory is made for each of BATS \textbf{runs, files} and \textbf{tests}.
- BATS code does \textbf{not} ~cd~ to the temporary directory by default.
- WCT/BATS provides ~cd_tmp [<context>]~ function to do that.

#+begin_example
setup_file () {
  cd_tmp          # cd to the "file-context" temp dir
  # ...
}
@test "some test" {
  cd_tmp          # cd to the "test-context" temp dir
  # ...
  cd_tmp file     # cd explicitly to "file-context"
  # ...
}
#+end_example

* Keeping BATS temporary directories

** Retain BATS' randomly generated temporary directories:
#+begin_example
$ bats --no-tempdir-cleanup test/test/test_bats.bats
# ...tests run and finally prints:
BATS_RUN_TMPDIR: /tmp/bats-run-V5XpTD
$ rm -r /tmp/bats-run-V5XpTD
#+end_example

** Pre-defining temporary directories for ~cd_tmp~:
#+begin_example
$ WCTEST_TMPDIR=$(pwd)/tmp bats test/test/test_bats.bats
$ rm -r tmp
#+end_example

** Notes
It is only when (re)using the fixed ~WCTEST_TMPDIR~ that the ~run_idempotently~ will actually run idempotently!

* A sampling of WCT BATS functions

- ~wct~ runs the ~wire-cell~ command, ~wcb~ runs the Wire-Cell build command, \\
   ~version~ gives WCT version string.
- ~compile_jsonnet~, ~dotify_graph~ work with WCT config files.
- ~file_larger_than~ tests that a file has at least some amount of data.
- ~topdir~, ~blddir~, ~srcdir path~, ~relative_dir path~, finds paths in source.
- ~usepkg <pkg>~, add ~build/<pkg>~ into ~PATH~ and define ~$<pkg>_src~ pointing to source directory.
- ~wcb_env~ set all Waf environment variables as shell environment variables.
- ~wcb_env_value <varname>~ echo the Waf environment variable value.
  - Run ~./wcb dumpenv~ to see what Waf variables are defined.
  - ~WCxxx~ points to ~wirecell-xxx~ programs from ~wire-cell-python~, if available.

* The WCT test data repository

Files produced by BATS tests are \textbf{ephemeral} in temporary directories.

But, tests can "save out" files to the \textbf{WCT test data repository} located at:

#+begin_example
build/tests/input/<dirs>/<files>
build/tests/<category>/<version>/<test-name>/<files>
#+end_example

- The ~/input/~ provides a few data files purely for consumption.
- The ~/<category>/~ names intention, eg \textbf{plots}, \textbf{history}, \textbf{reports}.
- The ~<version>~ is that of the software producing the files (Waf variable ~VERSION~).
- ~./wcb packrepo~ packs repo to tar files.  ~./wcb --tests~ installs them.
  - for now, remote repo lives [[https://www.phy.bnl.gov/~bviren/tmp/wcttest/data_repo/][here]] and is manually populated from repo packs.

* Saving files to test data repo from BATS

\textbf{The repo is not a dumping ground!}

Only "save out" files with clear intention how they will be used longer term.

A "save out" is done with WCT's ~wct-bats.sh~ library function ~saveout~:

#+begin_example
@test "some history test" {
  # make somefile.npz here....
  saveout -c history somefile.npz
}
@test "some plotting test" {
  # make someplot.png here....
  saveout -c plots someplot.png
}
#+end_example

* Test data repository categories

- input :: created by hand with special input data files (depos, frames, etc).
- plots :: for saving data visualizations in PNG, PDF format.
- history :: for select data files output from each software version.
- report :: collecting from \textbf{plots} and processing from \textbf{history} to produce files for human inspection (ie, web pages) that cover multiple software versions.

* Using BATS tags

BATS supports placing "tags" on tests in comments and WCT uses them:


#+begin_example
  # bats test_tags=history
  @test "make history" {
    # ...
    saveout -c history my-file-for-history.npz
  }

  $ bats --filter-tags history [...]
#+end_example

* BATS tags reserved by WCT

- ~history~ :: the test produces official "history" files for the data repo.
- ~report~ :: the test produces a "report" of files saved to output.
- ~implicit~ :: the test only performs weak, implicit tests ("it ran and didn't crash").
- ~issue:<number>~ :: The test is relevant to GitHub issue of the given number.
- ~pkg:<name>~ :: The test is part of package named ~<name>~ (~gen~, ~util~, etc)
- ~topic:<name>~ :: The test relates to topic named ~<name>~ (~wires~, ~response~, etc)

** So far, only \textbf{history} tag is used for anything.
- Will definitely use \textbf{report} to narrow execution to build reports.
- Others may be useful, but can be ignored for now.


* (Re)Making history

New tests are invented and we want to run them against old WCT software.

#+begin_example
./test/scripts/multi-release-testing \
   ~/wct/releases/rel{21,22,23,24} \
   ~/wct/development/master ~/wct/development/0.24.x
#+end_example

- Runs tests and place all ~saveout~ results in the \textbf{current release area}.
- Runs tests in 4 named releases, 2 development areas, \textbf{per-release parallelism}.
- Requires an ~.envrc~ file exists and manages each areas environment.
- Runs only the tests with a tag of ~history~.

* History is a work in progress

Largely needs to be done by an "expert"
- Some old code can not be run by new tests.
  - We define suitable old versions in Waf env var ~TEST_DATA_VERSIONS~.
- Requires many software release environments, each managed with [[https://direnv.net/][direnv]].
- Manual ~packrepo~ of results and upload to my web area.

  



* Further documentation of WCT testing system

WCT testing has comprehensive documentation:

- Main entry point on github 

https://github.com/WireCell/wire-cell-toolkit/blob/master/test/README.org

- Nicely rendered version (may be out of date from GitHub):

https://wirecell.bnl.gov/test/README.html

- Of course, existing tests provide wealth of examples:

#+begin_example
$ ls */test/{atomic,test}*.cxx|wc -l
199
$ ls */test/test*.bats|wc -l
17
$ ls */test/doctest*.cxx | wc -l
4
#+end_example

* 

\Huge

\[ \mathcal{FIN} \]

* Backups slides

* What is software testing?

\Large
#+begin_quote
Executing the software in a way that asserts expected behavior.
#+end_quote

* What is testing software?

- A "test" is software that exercises the software under test.

- A "test" must *assert* expected behavior.
  - It must be possible to fail or it is not a test. 

- A "test" must require no special knowledge to run.

- A "test" may be defined on a \textbf{spectrum} of code scale:

  - a code fragment inside the software,

  - a single program exercising the software,

  - multiple, inter-dependent programs,

  - a "suite" consisting of many of the above.


* What is a testing framework?

\Large
#+begin_quote
Guidelines, rules and/or additional software that are used in
developing and executing tests in a consistent and flexible manner.
#+end_quote

\normalsize
\vfill
WCT provides a testing system that hits on all these qualities.


* Categories of testing


\scriptsize
-    Acceptance :: Verifying whether the whole system works as intended.
-    Integration :: Ensuring that software components or functions operate together.
-    Unit testing: Validating that each software unit performs as expected. A unit is the smallest testable component of an application.
-    Functional :: Checking functions by emulating business scenarios, based on functional requirements. Black-box testing is a common way to verify functions.
-    Performance :: Testing how the software performs under different workloads. Load testing, for example, is used to evaluate performance under real-life load conditions.
-    Regression :: Checking whether new features break or degrade functionality. Sanity testing can be used to verify menus, functions and commands at the surface level, when there is no time for a full regression test.
-    Stress :: Testing how much strain the system can take before it fails. Considered to be a type of non-functional testing.
-    Usability :: Validating how well a customer can use a system or web application to complete a task.

Cribbed from https://www.ibm.com/topics/software-testing


# Local Variables:
# eval: (fix-latex-previews)
# End:
