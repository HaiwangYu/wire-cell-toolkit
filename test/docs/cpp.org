* C++

WCT tests of small code coverage (ie "unit" tests) typically must be written in C++ as a small program (ie, provides ~main()~).  In this document we walk though writing a test.

** The example test

After reading section [[Framework]]]] for an overview and [[Writing tests]] to get a general understanding we decide to place our test in the "atomic" aka "test" category and pick a "name" ~idft~.  We place it here:

#+begin_example
aux/test/test_idft.cxx
#+end_example
See below for why ~aux~ was chosen.
This tests various aspects of the ~IDFT~ interface implementations.  It
can be run as an atomic test:

#+begin_example
./build/aux/test_idft
#+end_example
It can also be run in a variant form by giving optional command line argumetns:

#+begin_example
./build/aux/test_idft FftwDFT WireCellAux
./build/aux/test_idft TorchDFT WireCellPytorch
./build/aux/test_idft cuFftDFT WireCellCuda
#+end_example
The first variant is actually identical to the atomic call.  The latter two require that WCT is build with support for PyTorch and CUDA, respectively.  An atomic test for each of the latter two variants can be found in their respective packages.

Note, C++ tests require particular attention to dependencies.  The ~test_idft~ is a little special in that it only has build-time dependency on the ~iface~ sub package yet it is placed in the ~aux~ package and can have run-time dependency on other higher-level packages via WCT's plugin and component factory mechanisms.  In its default calling, it relies on the ~FftwDFT~ component being available.  This component is provided the ~WireCellAux~ plugin library (from the ~aux~ sub package) and so this minimal run-time dependency is satisfied by placing the test in the ~aux~ sub package.  Depending on the variant form, it must be run in a context with either the ~WireCellPytorch~ or ~WireCellCuda~ plugins available.  We will show how to register these variants so they are run when these optional sub packages are built.

** Getting started

We start with an initial do nothing test that always succeeds:

#+begin_example
int main(int argc, char* argv[]) {
    return 0;
}
#+end_example
We may build (which auto-runs) and manually run it with:

#+begin_example
./wcb --target=test_idft
./build/aux/test_idft
#+end_example
We use ~--target~ to avoid building/running the other tests.

** Fleshing out

We may start by writing some test code directly in ~main()~.  As that grows we look for refactoring so we can easily expand coverage with minimal coding.  We end up with many ~test_xxx()~ functions which are static or templated:

#+begin_example
static
void test_2d_threads(IDFT::pointer dft, int nthreads, int nloops, int size = 1024)
{
    // ...
}
template<typename ValueType>
void test_2d_transpose(IDFT::pointer dft, int nrows, int ncols)
{
   // ...
}

int main(int argc, char* argv[])
{
    // ...
    test_2d_transpose<IDFT::scalar_t>(idft, 2, 8);
    // ...
    return 0;
}
#+end_example

** Failing tests

A test is successful if it completes with a return status code of zero.  A failed test can be indicated in a number of ways:

- return non-zero status code
- ~throw~ an uncaught C++ exception 
- call ~assert()~ or ~abort()~
- call WCT's ~Assert()~ or ~AssertMsg()~.

The test developer is free to use any or a mix of these methods and is strongly urged to use them pervasively throughout the test code.  

** WCT C++ testing support

As introduced above, WCT provides some support for testing.  The first are simple wrappers around ~assert()~ and one that will print a message if the assertion fails:

#+begin_example
#include "WireCellUtil/Testing.h"

int main()
{
    int x = 42;
    Assert(x == 42);
    AssertMsg(x == 0, "Not the right answer");
    return 0;
}
#+end_example


#+begin_example
#include "WireCellUtil/TimeKeeper.h"
#include "WireCellUtil/MemUsage.h"
#include "WireCellUtil/ExecMon.h"
#+end_example

- ~TimeKeeper~ :: a "stopwatch" to record time along with a message for various steps in a test
- ~MemUsage~ :: similar but to record memory usage
- ~ExecMon~ :: combine the two.

See ~test_timekeeper.cxx~, ~test_memusage.cxx~ and ~test_execmon.cxx~, respectively, in ~util/test/~.

** Output diagnostic files

By definition, an *atomic test* may not produce any files that are known to ~wcb~.  However, such a test is still free to produce files.  A typical reason for this is to produce diagnostic plots or other files for later examination by experts.  Here is the convention that should be followed in naming those output files.

#+begin_example
int main(int argc, char* argv[])
{
    std::string name = argv[0];
    std::string outname = name + ".ext";
    std::string outname2 = name + "_other.ext";
    // open and write to outname and outname 2....
    return 0;
}
#+end_example

This will produce files under ~build/~ which are siblings to the program itself.  

** Found input files

Likewise, an atomic test must not expect any input files specified by the caller.  However, it may load files that can be found from the environment.  A common example is to find a WCT "wires" file or others provided by ~wire-cell-data~.  Here is a C++ pattern do that in a way that naturally allows an atomic test to also be called in a variant manner.

#+begin_example
int main(int argc, char* argv[])
{
    const char* filename = "microboone-celltree-wires-v2.1.json.bz2";
    if (argc > 1) {
        filename = argv[1];
    }
    // use filename...
    return 0;
}
#+end_example

See ~util/test/test_wireschema.cxx~ for an example.  

For this kind of file to be found the user *must* define ~WIRECELL_PATH~ to include a directory holding the contents of ~wire-cell-data~.

In principle the path in ~argv[0]~ may also be used to locate the top of the ~wire-cell-toolkit~ source in order to locate files provided by the source and use them as input.

