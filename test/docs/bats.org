#+title: Guidance on writing BATS tests for WCT
#+latex_header: \usepackage[margin=1in]{geometry}
#+options: ':t toc:t

Writing tests as shell command lines is best when the feature under test is exercised by executing one or more programs.  Such tests tend to be closer to the "integration test" side of the spectrum.  Another reason to prefer providing tests as shell command lines is if there are many related but independent tests to run and adding them as individual atomic or variant tests would cause the Waf DAG to grow to unreasonable size.  While WCT supports trests written as [[file:shell.org][plain shell scripts]] it is much preferred to provide command line tests in the form of Bash automated testing system ([[https://bats-core.readthedocs.io/][BATS]]) tests.

* BATS overview

A BATS file is essentially a Bash shell script with a number of "special" functions that look like the following:

#+begin_example
@test "description of test" {
  # ... body of test
}  
#+end_example

With very little additional effort compared to plain shell scripts, a BATS test then provides added benefits such as:

- standard forms to run a suite of tests and select individual
- standard test protocol
- stdout/stderr management
- simple ways to run commands and check for success

One major thing BATS does *not* provide is a way in which to connect different tests into a DAG.  However, by registering them as variant tests with ~wcb~, this can be accomplished.

* BATS in WCT

BATS is under development and versions provided by even updated distributions like Debian may not be new enough to be used with WCT.  Thus, WCT provides a copy of bats in the source.  It will be found by ~wcb~ and may be used by you, dear user.  For interactive use, you may find it convenient to set an alias:

#+begin_example
  $ alias bats=/path/to/my/wire-cell-toolkit/test/bats/bin/bats
#+end_example
In addition, WCT provides a BATS support library file at ~test/wct-bats.sh~ to assist in writing BATS tests for WCT.  To use, it must be loaded via a path relative to the BATS file.  For example from ~apps/test/test_apps.bats~:

#+begin_example
  $ cat test/test/test_bats.bats
  #!/usr/bin/env bats
  
  load "../../test/wct-bats.sh"
  
  @test "test wire-cell help" {

      # Set environment with certain wcb Waf build variables
      wcb_env
  
      # Defined by wcb_env, "run" by bats
      run $WIRE_CELL --help
  
      # Bats will only show this if test fails.
      echo "$output"
  
      # Assert no error status code
      [[ "$status" -eq 0 ]]
  
      # Assert expected info
      [[ -n "$(echo $output | grep 'Wire-Cell Toolkit')" ]]
  }
#+end_example
The ~test/wct-bats.sh~ file is heavily commented and it is best to read this file to learn what functions it provides. 

* Running BATS tests

A BATS test should run from anywhere:

#+begin_example
bats test/test/test_bats.bats
#+end_example
When run by default, all ~@test~ functions in a BATS file will be.  A subset of tests with names that match a filter can be selected for running.

#+begin_example
bats -f "test wct bats" test/test/test_bats.bats
#+end_example

* Create a BATS test file

See [[file:writing.org]] for general guidance on writing WCT tests.  
Variant BATS tests are described below.  Most BATS test are expected to be *atomic* (see [[file:framework.org][Framework]] for definition) and so their source should be found as:

#+begin_example
<pkg>/test/test_<name>.bats
#+end_example
As with all tests, select a ~<name>~ that is unique to all of ~*/test/test_*.*~ and which describes the nature of the test.  If the test relates to an issue on GitHub (and ideally there is a test for every resolved issue) then this is an excellent pattern:

#+begin_example
<pkg>/test/test_issueNNNN.bats
#+end_example

BATS tests should be placed in a ~<pkg>~ which best provides the run-time dependencies.  For example, if PyTorch is required they should be placed in the ~<pytorch>~ sub package.  If there is no single package to assure the correct dependency context the test must be added as a variant.  See [[file:variant.org]] for how that may be done.

* First steps

Edit the ~.bats~ file, add the ~@test~ function:

#+begin_example
  #!/usr/bin/env bats
  
  load ../../test/wct-bats.sh
  
  @test "assure the frob correctly kerplunks" {
      echo "nothing yet"
  }
#+end_example
Best to pick a name that describes a positive test outcome.
Check that the test works:

#+begin_example
  $ bats <pkg>/test/test_issueNNNN.bats
#+end_example

At this point thet test does nothing that can fail so it is not really testing anything.  Now that the basic exercising of the test works, real testing can begin.  Below we progressively add more tests constraints.  It is very good idea to build up tests in this way as you hunt the bug.  This means tests will initially fail.  Don't fix the bug first but rather write the tests and fix the bug so the failing tests now succeed.

* Basic elements of a test

Typically an ~@test~ will consist of one or more stanzas with the following four lines:

#+begin_example
  run some_command             # (1)
  echo "$output"               # (2)
  [[ "$status" -eq 0 ]]        # (3)
  [[ check_output "$output" ]] # (4)
#+end_example
We explain each:
1. Use Bats ~run~ to run some command under test.
2. The ~run~ will stuff command output to ~$output~ which we echo.  We will only see this output on the terminal if the overall test fails.  (see logging below).
3. Assert that the command exited with a success status code (~0~).
4. Perform some check on the output.  The ~check_output~ is not a real command but instead just shows an example.  We might ~grep~ the ~$output~ for some expected strings, save the output to a file and ~diff~ it against expected output, or any other manner.  Alternatively, the ~some_command~ may write output files that we ~diff~ or otherwise compare with prior "blessed" output.

* Start up and tear down

In addition to the special ~@test "" {}~ function forms, BATS supports two functions that are called once per file.  The first is called prior to any ~@test~ and the second called after all ~@test~.

#+begin_example
function setup_file () {
  # startup code
}
function teardown_file () {
  # shutdown code
}
#+end_example
One example for using ~setup_file~ is to run any long-running programs that produce output required by more than one ~@test~.

* Test logging

BATS uses the [[https://testanything.org/]["test anything protocol"]] to combine multiple tests in a coherent way.  We need not be overly concerned with the details but it does mean that BATS captures ~stdout~ and ~stderr~ from the individual tests.  When the user wishes to see diagnostic messages directly this causes annoyance.  But, no worry as there are three mechanisms to emit and view such user diagonstics.

** Logging on failure

By default, ~bats~ will show ~stdout~ for a test that fails so simply ~echo~ or otherwise send to ~stdout~ as usual

#+begin_example
  @test "chirp and fail" {
      echo "hello world"
      exit 1
  }
#+end_example
Running ~bats~ on this test will fail and print ~hello world~.

** Logging on success

The output of successful tests can also be shown.

#+begin_example
  @test "chirp and succeed" {
      echo "goodbye world"
  }
#+end_example
Running ~bats~ as:

#+begin_example
  $ bats --show-output-of-passing-tests chirp.bats
#+end_example
will show ~goodbye world~.

** File descriptor 3.

Output to the special file descriptor ~3~ will always lead to that output to the terminal.  

#+begin_example
  @test "chirp no matter what" {
      echo "Ahhhhhhhh" 1>&3
  }
#+end_example
Please avoid using this except in special, temporary cases, as it leads to very "noisy" tests.

* Input and output files

** Files with atomic tests

As *atomic* files are by definition executed with no arguments the Waf unit test framework will neither provide input files nor expect output files from the test.  An *atomic* test may nonetheless consume and produce files internally.  See section [[Implicit files]]. 

** Files with variant tests


For a variant BATS test see bw is to be *variant* then any name not starting with ~test_~ may be used.  However, by convention this pattern is often chosen:

#+begin_example
<pkg>/test/check_<name>.bats
#+end_example

For the rest of the document we will use ~test_~ or ~check_~ prefixes to signify the test is  *atomic* or *variant*, respectively.


On the other hand, a *variant* test may be registered in a ~wcb~ rule such that input files may be provided and output files may be expected.  The only way to communicate these files into the BATS test is via environment variables.

See the file [[file:../wscript_build]] and note:

- We convert files into Waf nodes to better share them between two rules.
- We define a rule named ~check_batsio~ with a command line build from the Waf arrays ~SRC~ and ~TGT~ that correspond to the arrays given by the ~source~ and ~target~ arguments, holding our nodes.
- We invent ~WCTEST_*~ environment variables to pass the absolute path to the files.
- We give the ~.bats~ script itself as an element in the ~source~ array so that it is a dependency in running the test.

The BATS test itself is in [[file:../test/check_batsio.bats]].  Note these aspects of its code:

- We have the values of ~WCTEST_*~ variables to learn what input we consume and output to produce.
- We do various sanity tests using bash's ~[[ ... ]]~.  Had any failed, the test would fail.
- The production of the output file is done with a simple ~cp~.  Had this test *failed* to produce output then the Waf unit test would notice the failure.

** Implicit files

An *atomic* and a *variant* test may implicitly attempt to consume and produce files internally.  These files will not be visible to ~wcb~ and so can not be used to form dependencies to other Waf tasks.

The ~wct-bats.sh~ library provides some functions that will help test functions work with files.

#+begin_example
  local path="$(download_file <url> [<target>])"
#+end_example
This function will attempt to download the file at the URL to a cache under ~build/~ and return the absolute path to the downloaded file.  By default the file will be named as the basename of the URL unless ~<target>~ is given.

#+begin_example
  local path="$(resolve_file <filename>)"
#+end_example
This function will attempt to locate and return the absolute path for a filename.  It search current directory, the downloads cache, the ~test/data/~ directory and then checks ~WIRECELL_PATH~ and a special ~WIRECELL_TEST_DATA_PATH~.

** Temporary files

Every BATS run, file and test is given a temporary directory to hold any intermediate files.

- ~$BATS_RUN_TMPDIR~ :: a base directory for one run of the ~bats~ command
- ~$BATS_FILE_TMPDIR~ :: a directory for use at file level
- ~$BATS_TEST_TMPDIR~ :: a directory for use by each test

Typically, only the last used.  The ~wct-bats.sh~ library provides some helpers to work with temporary areas:

#+begin_example
  local here=$(cd_tmp)   # move to WCTEST_TMPDIR or BATS_TEST_TMPDIR
  # ...                  # do stuff in the temp area
  cd $here               # return to initial dir
#+end_example
The ~cd_tmp~ will change to ~$WCTEST_TMPDIR"~ if define or to "~$BATS_TEST_TMPDIR~" which BATS will define unique for each test.  The former may be used to force tests that use ~cd_tmp~ to re-run in a prior directory.  In combination with writing idempotent test code, this can allow rerunning tests more quickly.  This is mostly a benefit during development of long-running tests.

The ~cd_tmp~ echos the current working directory which may be captured in order to return after using the temporary directory.  This is not required unless subsequent code in the test function needs it.

By default ~bats~ will remove ~$BATS_RUN_TMPDIR~ (but not ~$WCTEST_TMPDIR~) after testing.  When tests fail it can be useful to examine what was placed in the temporary directories.  To allow this run the test like:

#+begin_example
  $ bats --no-tempdir-cleanup path/to/test_foo.bats
#+end_example
The temporary directory will be printed to the terminal. 

** Idempotent tests

Some tests are long running and multi stage.  As just described, a test should run in a per-test temporary directory by calling ~cd_tmp~.  When developing tests or investigating failures, it can be very painful to run and re-run the same test many times.  By setting ~WCTEST_TMPDIR~ we can control where the test runs, but we must still write the tests to be *idempotent* to allow us to quickly run and re-run them and not repeat the portions that pass. 

Adding idempotency to tests simply comes down to adding test for command output files and only running the command if the file is missing.  An example:

#+begin_example
  @test "an idempotent test" {
    myout="myoutput.txt"
    if [ -f "$myout" ] ; then
      echo "reusing $myout"
    else
      date > $myout
    fi
    # ...
  }
#+end_example
Here the ~date~ command stands in for a "long running" program.  The ~echo~ is not seen on the terminal unless the test later fails.   That's it.  Now when running and re-running the test with ~WCTEST_TMPDIR~ set it will only call the "slow" ~date~ program once.

Another common pattern is one initial, long-running command followed by many faster tests that utilize the results of that first command.  This pattern is well served by using the Bats ~setup_file~ function to run the command in the temporary directory at "file scope" via ~cd_tmp file~.  As default scope is per-test, each subsequent test must locate that file-scope temp.

#+begin_example
  function setup_file -o output.dat () {
    cd_tmp file
    run my_slow_command
    [[ "$status" -eq 0 ]]
  }

  @test "A test running in file temp dir" {
    cd_tmp file
    [[ -s output.dat ]]
  }

  @test "A in test temp dir using file temp dir" {
    local ft="$(tmpdir file)"
    cd_tmp
    [[ -s "$ft/output.dat" ]]
  }
#+end_example


* Archiving results

The ~wct-bats.sh~ library provides support for producing an "archive" of files from an individual Bats test or a Bats test file.  An archive is simply a Zip file that may later be found in the ~build/~ area.  The intention of test archives is to retain a carefully selected subset of files for later human inspection.  An archive should *not* be used to arbitrarily collect all files that may be produced by a test.  It is expected that these archives will be directly consumed by a future test summary "database" or "browser" of some form.

** Producing files for archive

Files for archive are produced like any files except that they must reside in a Bats temporary directory.
As described above, this should be achieved naturally by calling ~cd_tmp~ in an individual test:
#+begin_example
@test "my test" {
  cd_tmp
  # ...
}
#+end_example
Or by calling ~cd_tmp file~ in the special test-file ~setup_file~ function:
#+begin_example
setup_file()
  cd_tmp file
  # ...
}
#+end_example

** Naming files for archive

Each archive is placed under ~build/~ in a sub directory named based on the test.  Thus it is not necessary to prefix the names of files that are to be archived with additional test-specific labels.

However, if a test developer wishes to add this redundant information consider using ~${BATS_TEST_NAME}~ in the context of a ~@test~ function and ~$(basename $BATS_TEST_FILENAME .bats)~ in the context of a ~setup_file~ function.

** Individual test and test file archives

Bats provides a separate temporary directory for each individual test and one for the test file as a whole.  It is possible to provide an archive from each of these contexts.  It is also possible for an individual test to provide a file to the test-file level archive.  The one restriction is that every file to be archived must be placed in the temporary directory context for that archive.  Some examples:

#+begin_example
# special file-level function
setup_file () {
  cd_tmp file
  touch file_level.txt
  # The special "file" argument gives the context
  archive_append file file_level.txt
}

@test "my individual test" {
  cd_tmp
  touch test_level.txt
  archive_append test_level.txt

  cd_tmp file
  touch another_file_level.txt
  archive_append file another_file_level.txt

  # save the test-level archive
  archive_saveout
}

# special file-level function
teardown () {
  archive_aveout file
}

#+end_example





** Naming test-file context files for archive

When files for archive are produced at file-level in the ~setup_file~ file 

Sometimes tests can make files that should live beyond temporary use.  For example, tests may produce files for later inspection by human.  The ~wct-bats.sh~ provides the concept of a test "archive" for these files.  An archive is simply a Zip file associated with a temporary directory context (again, "test", "file", etc).

The test must explicitly add files to an archive and then save the archive out.
#+begin_example
@test "test something and make an archive" {
  cd_tmp

  touch junk.txt
  archive_append junk.txt

  touch junk1.txt junk2.txt
  archive_append junk1.txt junk2.txt

  archive_saveout
}
#+end_example
A test file context archive may also be created.  It may be appended to in the ~setup_file~ function and must be saved in the ~teardown~ function (if it is to be saved).  In the mean time, it is possible for ~@test~ functions to also append to the archive.  As Bats is used in WCT this is safe.  However, if you force Bats to run test in parallel, the results are undefined.

#+begin_example
setup_file () {
  # a file context archvie
  touch junk.txt
  archive_append file junk.txt
}

@test "a test adding to test file context archive" {
  cd_tmp file
  touch junk2.txt
  archive_append file junk2.txt
}

teardown () {
  archive_saveout file
}
#+end_example

* Summarizing results

* Visualizing results

