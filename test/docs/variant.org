#+title: WCT variant tests
#+latex_header: \usepackage[margin=1in]{geometry}
#+options: ':t toc:t

*This describes some unsupported experimental features.  Best to ignore.*

* Atomic vs variant

In all cases, performing a test involves executing a program by and known to the WCT build system (~wcb~).    The WCT testing framework categorizes each test based on how it is registered with the build system and participate in the execution of the directed graph that governs the build.  There are two categories:

** Atomic tests

An *atomic* test is one that may run follows the source file naming convention above and which may execute as a disconnected task graph node.  This means that any files the task may consume or produce may not serve as edges connecting tasks in the graph.  But, see [[Execution stages]] for how a coarse implicit dependency can be used.

Furthermore, an atomic test must not require any (but may accept some) command line arguments.  Executing the program with no arguments allows it to be used as an atomic test.  

The majority of WCT tests are now, and are expected to remain, atomic.  When writing new tests, consider making them atomic.

** Variant tests

A *variant* test is, in principle, an arbitrary build system task that has arbitrary connections with the wider build system task graph.  It requires the developer to explicitly provide this task graph integration.  See [[Variant test integration]].

A program that supplies an atomic test may be used in a variant test if that program accepts command-line arguments which are all optional.  One or more variant tests can be registered which supply a variety of these command-line options.  But, note, this variety can also be expressed by developing an interpreted atomic test that iterates over the desired variations.

Very few WCT tests are in the variant test form.  When writing new tests, consider making them atomic.

The rest of this document assumes a test is *atomic* unless explicitly described as *variant*.



* Variant tests

In WCT, a *variant test* is formed when a test program requires command line arguments.  These command line arguments may specify file names which are known to ~wcb~.  Those files may then form connections between other variant tests or in general other Waf tasks so that the variant test becomes a connect part of Waf's DAG.

* Basics of registering

We must explicitly register a variant test with ~wcb~ in a ~<pkg>/wscript_build~ file.  There we specify a parameterized command line string and optional source input and/or target output files.

A simple example from ~util/wscript_build~:

#+begin_example
with bld.smplpkg('WireCellUtil',
                 use='SPDLOG BOOST FFTW EIGEN DYNAMO JSONCPP JSONNET ZLIB',
                 test_use='WireCellApps') as p:
    
    p.rule("${WIRE_CELL} --help 2>&1 | grep 'Command line interface to the Wire-Cell Toolkit' > ${TGT}",
           name="wire-cell-help",
           target="wire-cell-help.log")
#+end_example
Several things to note in this short bit of code:
- The usual ~smplpkg()~ call returns a Python context manager as ~p~.
- The ~p.rule()~ is the general registration function, more on this below.
- The first argument is the parameterized command line.
- An explicit ~name~ should be given so the task shows in ~./wcb list~ and may be used in ~./wcb --target=<name>~.
- A ~target~ argument gives a file name (or a list of file names) of output files
- A ~source~ argument, not used in this example, provides input files

The parameterized command line makes use of ~${WIRE_CELL}~ which is set to the path to the ~wire-cell~ program that is also built by ~wcb~.  The output ~${TGT}~ is replaced by the contents of the ~target~ argument.  Had ~target~ been a list of file names, ~${TGT}~ would be replaced by a space-separated version of that same list.  Individual files can be referenced, eg as ~${TGT[0]}~ and their full paths can be assured with ~${TGT[0].abspath()}~.

If another rule exists that uses ~wire-cell-help.log~ as its input, ~wcb~ will assure to run ~wire-cell-help~ first.
See ~wire-cell-toolkit/util/wscript_build~ for various examples of how such sub-DAGs can be formed.

* A variant conditional on dependencies

The ~test_idft~ atomic test may also be used as a variant test.  See [[file:cpp.org]] for more on this particular test.
The variants have different run-time dependencies as they will load a plugin which is given on the command line in order to use a particular component ~IDFT~, also named on the command line.

We may assure that the variant requiring a particular dependency is only run with that dependency is available by registering the variant in a context that otherwise has that dependency.  For example, the PyTorch variant is registered in ~pytorch/wscript_build~ like this:

#+begin_example
with bld.smplpkg('WireCellPytorch', use='WireCellAux LIBTORCH') as p:
    p.rule("./${SRC}", source=["test_idft", "TorchDFT", "WireCellPytorch"])
#+end_example

The *rule* command line here uses a small trick.  Just as described for ~${TGT}~ above, the ~${SRC}~ array variable is expanded to hold the elements of the list provided by the ~source~ argument, separated by spaces.  We provide the ~test_idft~ as the first in the "source" list so that the rule generates a Waf task that depends on that program being built.  The order of the sources also matches the required command line calling sequence.  Had some more complex command line been required we would have provided the rule string with ~${SRC[0]}~ etc elements.

By placing this in ~pytorch/wscript_build~ the test will only be run when WCT is build with support for ~pytorch~.  Alternatively, when that sub-package level switch is not possible (eg, there is no single sub package providing all required dependencies), the *rule* can be defined inside a test for some package support.

For example, here is a contrived example (not) in ~test/wscript_build~ that depends on both CUDA and ROOT.  Since it requires both, we can not put it in either the ~root/wscript_build~ nor ~cuda/wscript_build~.

#+begin_example
with bld.smplpkg('WireCellTest', use='WireCellApps') as p:
    if p.has('cuda root'):
        p.rule("./${SRC}", source=["check_cuda_and_root"])
#+end_example

FIXME: for such a thing to actually work, ~test~ needs to depend on both but in a way that does not totally break when ROOT or CUDA is excluded.  This is more a problem for building the fictional ~check_cuda_and_root~ program.  
