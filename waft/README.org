#+title: Wire-Cell Builder Waf Tools
#+latex_header: \usepackage[margin=1in]{geometry}
#+options: ':t toc:t
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

This repository holds some [[https://waf.io][Waf]] tools to help build the [[https://wirecell.bnl.gov][Wire-Cell Toolkit]] (or other) software.

Historically, WCT provided a command ~wcb~ which was ~waf~ + some extra tools from Waf plus the WCT specific build tools in the ~wirecell/waf-tools~ repository.  That repository has been copied to here, the `wire-cell-toolkit/waft/`  sub-package.  The ~wcb~ command may still be built from the contents here and used to build WCT itself or any Wire-Cell "user package".  In addition, the plain ~waf~ command may be used to build WCT.

The rest of this document describes how to remake the ~wcb~ command, how to use it and describes some of the tools customized for WCT.

* Packing ~wcb~

The ~wcb~ command is a packed version of ~waf~ with extra tools.  A script is provided to automate rebuilding ~wcb~:

#+begin_example
  $ ./waft/refresh-wcb -o wcb
#+end_example

Be sure to do this *before* making a release of WCT if ~waft/~ has changed.

* Using ~wcb~ 

for these instructions, when building WCT itself, you may substitute ~waf~ with ~./wcb~.

On well-provisioned systems, ~wcb~ builds the software automatically:

#+begin_example
  (1)$ ./wcb configure --prefix=/path/to/install
  (2)$ ./wcb 
  (3)$ ./wcb install
  (4)$ ./wcb test
  (5)$ ./wcb check
#+end_example

1. A one-time step so that dependencies may be located.
2. Build the project (output goes to ~./build/~).
3. Install elements of the build.
4. Build and execute "unit tests".
5. Build and execute integration/validation "checks".

In some environments, ~wcb~ may need help to find dependencies.  Hints can be given with ~--with-*~ type flags.  To see available flags use the online help:

#+BEGIN_EXAMPLE
  $ ./wcb --help
#+END_EXAMPLE

Packages can be included, excluded and located with the various ~--with-NAME*~ flags.  The rules work as follows:

1) If package is optional:

  - omitting a ~--with-NAME*~ option will omit use the package

  - explicitly using ~--with-NAME=false~ (or "~no~" or "~off~") will omit use of the package.

2) If package is mandatory:

  - omitting all ~--with-NAME*~ options will use ~pkg-config~ to find the package.

  - explicitly using ~--with-NAME=false~ (or "~no~" or "~off~") will assert.

3) In either case:

  - explicitly using ~--with-NAME=true~ (or "~yes~" or "~on~") will use pkg-config to find the package.

  - using ~--with-NAME*! with a path will attempt to locate the package without using ~pkg-config~.

When in doubt, explicitly include ~--with-NAME*~ flags.

* Using the =smplpkgs= tool to build suites of packages

The =smplpkgs= tool included in =waf-tools= provides a simple way to build a suite of software packages that have interdependencies without you, the developer, having to care much about the build system.

** Package organization 

To achieve this simplicity, some file and directory conventions for naming and organization must be followed, as illustrated:

#+BEGIN_EXAMPLE
  pkg1/
  ├── wscript_build
  ├── inc/
  │   └── ProjectNamePkg1/*.h
  ├── src/*.{cxx,h}
  ├── test/test_*.*
  ├── test/check_*.*
  └── test/wscript_check
  pkg2/
  ├── wscript_build
  ├── inc/
  │   └── ProjectNamePkg2/*.h
  ├── src/*.{cxx,h}
  ├── app/*.{cxx,h}
  └── test/*.{cxx,h}
#+END_EXAMPLE

Notes on the structure:

- The "sub packages" (~pgk1~, ~pkg2~) are top-level sub-directories.
- A  ~wscript_build~ file in each sub-package to declare the name of the sub package, dependencies and any special case build rules.
- A header file =<pkgdirname>/inc/<PackageName>/Xxx.h= are considered "public" and will be made available as ~#include "PackageName/Xxx.h"~.
- Library source (implementation and private headers) go under =<pkgdirname>/src/=
- Application ~main()~ source as =<pkgdirname>/app/app-name.cxx=.
- Units tests and integration/validation tests as  =<pkgdirname>/test/{test,check}_*.*=.  See the section [[Tests]] below.

The =<pkgdirname>= only matters in the top-level =wscript= file which you must provide.  The =<PackageName>= matters for inter-package dependencies.


** The per-package =wscript_build= file

Each package needs a brief (generally single line) file called =wscript_build= to exist at in its top-level directory.  It is responsible for declaring:

- The package name
- Library dependencies
- Any additional application dependencies
- Any additional test dependencies

Example:

#+BEGIN_SRC python
  bld.smplpkg('MyPackage', use='YourPackage YourOtherPackage')
#+END_SRC

Test and application programs are allowed to have additional dependencies declared.  For example:

#+BEGIN_SRC python
  bld.smplpkg('MyPackage', use='YourPackage YourOtherPackage', test_use='ROOTSYS')
#+END_SRC

* Tests

For more information on WCT testing see ~wire-cell-toolkit/tests/README.org~.  What follows is a brief introduction to the support here in ~wire-cell-toolkit/waft/~.

Atomic unit tests may be provided as:

#+begin_example
<pkg>/test/test*.<ext>
#+end_example

Depending on ~<ext>~ of:

- ~cxx~ or ~kokkos~ :: the source file will be compiled into a program of the same name (less ~.<ext>~).

- ~py sh bats jsonnet~ :: the source will be interpreted by a corresponding interpreter.

Atomic tests will also be run automatically unless suppressed with:

#+begin_example
waf --notests [...]
#+end_example

A "check" program with source found as:

#+begin_example
<pkg>/test/check_*.<ext>
#+end_example

Will be compiled but not run if the ~<ext>~ is compilable as above.

Arbitrary *variant tests* can be registered with Waf by registering their rule and inputs/outputs in

#+begin_example
<pkg>/wscript_build
#+end_example

For example,

#+begin_src python
  with bld.smplpkg('MyPackage', use='YourPackage YourOtherPackage') as p:
    p.rule("${WCSONNET} > ${TGT} 2>&1", target="wcsonnet-help.log")
#+end_src

Additional higher level methods are also provided:

- ~get_file(remote,local)~ :: download a remote file to a local one in the build via ~http://~, ~https://~ and ~scp:~.
- ~script(file)~ :: explicitly register a script (ie, one lacking a ~test_*.<ext>~ spelling)
- ~diff(one,two)~ :: do a diff on two files

See ~wire-cell-toolkit/util/wscript_build~ for examples.

** BATS tests

A file:

#+begin_example
<pkg>/test_*.bats
#+end_example

Will be run as an atomic unit test but may internally provide one ore BATS tests.


* Using ~wcb~ in your own project

The ~wcb~ command is designed to build Wire-Cell Toolkit and is not a
general purpose build tool.  However, it may be used to build packages
that are providing WCT plugin libraries or other derived packages.

To use it follow these steps:

1) copy WCT's [[https://github.com/WireCell/wire-cell-toolkit/blob/master/wscript][wscript]] and [[https://github.com/WireCell/wire-cell-toolkit/blob/master/wcb][wcb]] to your package directory.

2) create directory layout (see below)

3) possibly modify ~wscript~ (see below)

4) follow normal ~wcb~ build instructions

An example package is available at 



** Directory layout options

You may create a package with one or more subpackages like WCT itself
in which case each subpackage should have a ~wscript_build~ file as
described above.  

Or, a simple package may be created with ~inc/~, ~src/~, etc directly in
the top-level directory.  Simply put the contents of a ~wscript_build~
file in the main ~wscript~ file in the ~build()~ function.  For example:

#+begin_src python
def build(bld):
    bld.load('wcb')
    bld.smplpkg('WireCellJunk', use='WireCellUtil')
#+end_src

** Modify ~wscript~

The ~wcb~ tool is created to find WCT's dependencies but not WCT itself.
Nor does it predict new dependencies your own package may need.
However, it has a simple mechanism to extend the method to search for
dependencies.  In the ~wscript~ file, at top level the following code
extends ~wcb~ to find WCT itself.

#+begin_src python
from waflib.extras import wcb
wcb.package_descriptions["WCT"] = dict(
    incs=["WireCellUtil/Units.h"],
    libs=["WireCellUtil"], 
    mandatory=True)
#+end_src


** The top-level =wscript= file

The ~wscript~ file is Waf's equivalent to a venerable ~Makefile~.  Almost
all functionality is bundled into ~wcb~ so the ~wscript~ is relatively
empty.  Refer to WCT's:



* Internals

The ~wcb.py~ file holds what might otherwise be in a top-level ~wscript~ file.  It's main thing is to list externals that can be handled in a generic way (see next para) and also doing any non-generic configuration.  It also enacts some dependency analysis to avoid building some sub-packages.  It holds things rather specific to Wire-Cell.

The ~generic.py~ file provides a ~configure()~ method used to find most externals.  It results in defining ~HAVE_<name>_LIB~ and ~HAVE_<name>_INC~ when libs or includes are successfully checked for a given package.  These end up in ~config.h~ for use in C++ code.

The building of WCT packages themselves is governed by ~smplpkg.py~.  This file implements WCT sub-package build policy but omits information about specific WCT targets (~wcb.py~ holds that).  It thus may be used by non-WCT projects.
