#+title: Wire-Cell Gen

This is the Wire-Cell "gen" sub-package.  It provides components
related to generating simulated data.  In particular:

- simple ionization deposition (depos) generators,
- drifting depos in the bulk volume of the detector,
- diffusion of these charges as they drift,
- convolution of drifted ionization with detector responses
- sampling fluctuations,
- intrinsic and coherent noise simulation
- ADC waveform digitization. of charge on the wire planes.

What follows are various, non-exhaustive notes on parts of the
sub-package.


* Noise simulations

Noise simulations include intrinsic / thermal noise and noise which is
coherent across a group of channels.  Both are parameterized by a
number of *mean noise spectra*.

** Code intro

The intrinsic noise is produced by the ~AddNoise~ flow graph node which
delegates actual noise generation to a /noise model/ component.  The
~EmpiricalNoiseModel~ component is primarily used and it accepts a
*channel noise spectra file* which provides an array of individual
spectra that spans a variety of wire lengths.

The coherent noise is produced by the ~AddGroupNoise~ flow graph node.
It takes a *noise group spectra file* and a *channel group file*.  Each
spectra provides a coherent noise spectrum to be applied to a group of
channels.

** Providing noise spectra

Though details of these files differ, in all cases spectra are
supplied following these specifications:

- ~freqs~ :: an array of frequencies in WCT system of units (not, the
  base unit of frequency in WCT is [1/time] = 1/ns and *not* Hz).

- amps :: an array of *mean spectral amplitude* with each element a
  measurement corresponding to the same element of ~freqs~.

The ~amps~ vs ~freqs~ sampling need *not*, and likely should not, match the
internal sampling used in the simulation.  The input sampling need
note even be regular nor complete.  An input spectrum consisting of a
single sample will technically work.  However, for accuracy, enough
samples of the spectrum should be provided so that its shape is well
represented.  Internally, the input spectra will be *linearly
interpolated* and *constant extrapolated* to produce whatever sampling
the simulation requires.

The value of elements of the ~amps~ array must provide an *mean spectral
amplitude* (specifically not mode) and it must be properly normalized.
The following guidelines describe a procedure to produce input
spectra.

- Collect a set of raw ADC waveforms in some manner that *excludes
  signal*.  Examining the distribution of ADC in a waveform around the
  *median* ADC of that waveform is one good way to detect if it has been
  "contaminated" with signal.

- Apply the forward discrete Fourier transform (DFT) to each waveform
  using no FT normalization (do *not* divide by 1/N nor 1/sqrt(N)).
  This gives a complex spectra.

- Take the absolute value of that spectra to get a real spectral
  amplitude for that waveform.

- Repeat with all the waveforms in the set and form the *mean spectral
  amplitude* by simply summing on a per-frequency-bin basis and
  dividing by the number of waveforms in the set.

- Write out the result.  Values above the Nyquist frequency are not
  required.  Down sampling may be desired for large sets of spectra.

If creation of mean spectra is performed by WCT C++ the developer may
use:

#+begin_src c++
  #include "WireCellAux/Spectra.h"
  // ...
  IDFT::pointer dft = ...;
  WaveCollector wavecol(dft);
  for (auto wave : waves) {
      wavecol.add(wave);
  }
  auto spec = wavecol.mean();
#+end_src

** Sampling spectra

Current and any novel noise simulation components should use code like
this to generate their waveforms.

#+begin_src c++
  #include "WireCellAux/RandTools.h"
  #include "WireCellAux/Spectra.h"
  // ...
  using namespace WireCell;
  IRandom::pointer rng = ...;
  IDFT::pointer dft = ...;
  
  // We can make all fresh normal-distributed randoms but this will be
  // about 2-3x slower than recycling.
  // 
  // FreshNormals norms(rng);
  
  // The size we will sample
  const size_t nsamples = ...;
  
  // Maximize freshness by using a recylcing ring buffer size which is
  // larger than and coprime with the size we sample
  const size_t not_nsamples = nearest_coprime(2*nsamples, 1.7*nsamples);
  
  // See test_noise and 'wirecell-test noise' for to show this recycling
  // of randoms is valid.
  const double replacement_fraction = 0.02; // the default
  RecyclingNormals norms(rng, not_nsamples, replacement_fraction);
  
  // A full, real and mean spectrum [0-2*Nyquist].
  // See WaveCollector.
  std::vector<float> true_spectrum(nsamples);
  
  // Given full, real and mean spectrum, make some waves
  WaveGenerator wavegen(dft, norms, true_spectrum);
  for (size_t iwave=0; iwave<nexample; ++iwave) {
      auto wave = wavegen.wave();
      use_wave(wave);
  }
#+end_src

