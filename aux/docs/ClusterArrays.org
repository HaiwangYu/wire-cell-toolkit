#+title: Cluster Arrays
#+include: ../../docs/include-topic.org

Provides array representations of ~ICluster~.

The ~ICluster~ graph represents identity, attributes and associations of five types of objects related to WCT imaging.  In addition to the associations represented internally by the graph some vertex objects (nodes) carry additional information and references to objects that are external to the graph.  The ~ClusterArrays~ class provides methods to "flatten" the internal and external structure to a set of arrays.  This document describes the ~ClusterArrays~ interface and provides guidance on how to use the arrays it produces.

* Low-level array representation

The API provides arrays in the form of [[https://www.boost.org/doc/libs/1_79_0/libs/multi_array/doc/user.html][Boost.MultiArray]] types.

* Graph connection schema

Production of an ~ICluster~ graph is described in detail in the Ray Grid document.  Its structure is summarized by the /type graph/ from that document.  This graph illustrates the five types of nodes and the allowed types of edges between node types.

[[file:./cluster-graph-types.png]]

* Array schema

The array schema closely matches that provided by the python-geometric ~HeteroData~ interface with the following simplification:

- All node attributes are coerced to double precision floating point scalar values.

- No graph nor edge attributes. This results in a graph being represented by a set of *node arrays* and a set of *edge arrays*.

Each *node array* is of a given type.  An array type is defined by a tuple that labels the interpretation of the columns of an array.  The tuple elements map to node attributes.  The rows of an array map to node instances of a given type.

All *edge arrays* have two columns.  The first provides indices of rows in a "tail" array and the second in a "head" array".  An edge array is mapped to these two node arrays by an array naming convention based on *array codes* and *edge codes*.

Before listing these codes, one structural change must be understood.  The ~ICluster~ graph connection schema described above treats /channel/ (and /wire/ ) nodes as representing physical entities.  A given channel node may be reached through multiple ~s-b-m-c~ paths beginning from multiple slices.  The ~ICluster~ also holds internal to /slice/ nodes an ~ISlice::activity()~.  This provides a the amount of signal in a channel that contributes to the slice.  Furthermore, this /activity map/ information is a superset of ~s-c~ relationships that may be found by following ~s-b-m-c~ paths.  This is because some slice activity may not have contributed to forming blobs in the slice.  This activity map can not be coerced into an slice array column (it would be a "ragged array").

In order to faithfully preserve the /activity map/ in the array format, the ~ClusterArrays~ schema *does not follow the cluster graph* schema shown above.  Instead, the cluster array type graph is:

[[file:cluster-array-types.png]]

Comparing these two type graph representations:

- /channel/ nodes are replaced by /activity/ nodes
- /activity/ represents a channel in a slice (not just a physical channel)
- /activity/ holds a signal value and uncertainty
- a /channel-slice/ edge is added

The remaining vertex types and allowed edges are the same other as in the original cluster graph schema.  In particular, the /wire/ vertex type still represents a physical wire which is not specific to any particular slice.  All other vertices are per-slice.

* Nodes

We define /node array codes/ as the ASCII value of the lower case initial letter of the node array names: /activity (a), blob (b), measure (m), slice (s)/ and /wire (w)/.  For example, an activity array will have a label ~anodes~.  The /edge array codes/ are the combination of two node array codes in alphabetical order.  For example, the edges between /slice/ and /activity/ vertices are represented in an array with a name that includes the label ~asedges~. 

The remainder of this section describes the columns that make up each type of array.

** Common

The arrays are either of node type or edge type.  All node type arrays have common definitions for their first *two* columns:

0. [@0] /vdesc/, (int) the vertex descriptor counts the node in the graph
1. /ident/, (int) the value from the WCT object's ~ident()~ method

The additional columns that make each array schema unique are given in the sections below and there these two columns are not repeated.

** Activity

An /activity/ represents an amount of signal and its uncertainty collected from a channel over the duration of a time slice.

2. [@2] /val/, the central value of the signal
3. /unc/, the uncertainty in the value
4. /index/, (int) the channel index
5. /wpid/, (int) the wire plane id

** Wire

The wire array represents the "geometric" information about physical wire segments.

2. [@2] /wip/, (int) the wire-in-plane (WIP) index.
3. /segment/, (int) the number of segments between this wire segment and the channel input.
4. /channel/, (int) the channel ID (not row index).
5. /plane/, (int) the plane ID (not necessarily a plane index).
6. /tailx/, the x coordinate of the tail endpoint of the wire.
7. /taily/, the y coordinate of the tail endpoint of the wire.
8. /tailz/, the z coordinate of the tail endpoint of the wire.
9. /headx/, the x coordinate of the head endpoint of the wire.
10. /heady/, the y coordinate of the head endpoint of the wire.
11. /headz/, the z coordinate of the head endpoint of the wire.

** Blob

A blob describes a volume in space bounded in the longitudinal direction by the duration of a time slice and in the transverse directions by pairs of wires from each plane and it includes an associated amount of signal contained by the volume.

2. [@2] /val/, the central value of the signal
3. /unc/, the uncertainty in the value
4. /faceid/, (int) the face identifier (see note)
5. /sliceid/, (int) the slice ident
6. /start/, the start time of the blob
7. /span/, the time span of the blob
8. /min1/, (int) the WIP providing lower bound of the blob in plane 1.
9. /max1/, (int) the WIP providing upper bound of the blob in plane 1.
10. /min2/, (int) the WIP providing lower bound of the blob in plane 2.
11. /max2/, (int) the WIP providing upper bound of the blob in plane 2.
12. /min3/, (int) the WIP providing lower bound of the blob in plane 3.
13. /max3/, (int) the WIP providing upper bound of the blob in plane 3.
14. /ncorners/, (int) the number of corners
15. 24 columns holding /corners as (y,z) pairs/, 12 pairs, of which /ncorners/ are valid.

#+begin_note
The /faceid/ is not (necessarily) the ~IAnodeFace::ident()~ but is ~WirePlaneId afid(kUnknownLayer, iface->which(), iface->anode()).ident()~.
#+end_note

** Slice

A slice represents a duration in drift/readout time.

2. [@2] /val/, the central value of the signal.
3. /unc/, the uncertainty in the value.
4. /frameid/, (int) the frame ident number
5. /start/, the start time of the slice.
6. /span/, the duration time of the slice.

** Measure

A measure represents the collection of channels in a given plane connected to a set of wires that span one or more blobs overlapping in one wire plane.  Its includes an associated signal representing the sum of signals from the participating channels.

2. [@2] /val/, the central value of the signal.
3. /unc/, the uncertainty in the value.
4. /wpid/, the wire plane ID


* Edges

An edge array is of a type constructed as the concatenation of two node types, in alphabetical order.  Eg, a ~bw~ edge array holds edges between ~b~ and ~w~ nodes.  Each row holds tail and head indices into the corresponding tail and head arrays.  An edge array also holds an edge descriptor giving the edge order in the original graph.  Note, ~boost::graph~ edges do not provide this integer representation directly and thus it is expected to be formed as a simple count by the code that writes cluster array schema.  Code that reads cluster array schema should add edges in order of this edge descriptor.

0. [@0], (int) edge order
1. /tail/, (int) index of a row in a tail array
2. /head/, (int) index of a row in a head array   

* Persistence 

WCT supports persisting clusters in files. Three persistent schema exist: "graph", "array" and "tensor".

** Graph schema

The /cluster graph file schema/ matches very closely the data schema of the ~ICluster~ representation, which is why it is called cluster *graph* schema.  The file format is JSON with optional compression (~.json.gz~, ~.json.bz2~).  As it closely mimics the ~ICluster~ representation, the slice activity map is stored directly as an attribute in a slice s-node.

The ~ClusterFileSource~ and ~ClusterFileSink~ can persist /cluster graph file/ schema.

** Array schema

The /cluster array file schema/ matches the schema defined in this document.  This schema differs from /cluster graph schema/ in these ways.

1. A set of arrays represent the graph instead of a JSON data structure.  
2. Every node attribute is coerced to scalar double precision number.
3. c-nodes (physical channel) are removed and a-nodes (activity in channel in slice)  are added.
4. The slice activity map is expressed through a-s edges and adding signal value and uncertainty in the a-node properties.

The file format is that of any archive container supported by WCT iostreams (Zip and Tar with optimal compression).  Each array is represented in a Numpy file that is written to or read from the stream.  The names of the Numpy files encode the ~ICluster::ident()~ number and the array type.  This results in files in the container with names like:

#+begin_example
 cluster_6501_wnodes.npy
 cluster_6501_snodes.npy
 cluster_6501_bnodes.npy
 cluster_6501_mnodes.npy
 cluster_6501_anodes.npy
 cluster_6501_bsedges.npy
 cluster_6501_bwedges.npy
 cluster_6501_asedges.npy
 cluster_6501_bbedges.npy
 cluster_6501_bmedges.npy
 cluster_6501_awedges.npy
 cluster_6501_amedges.npy
#+end_example

The ~ClusterFileSource~ and ~ClusterFileSink~ can persist /cluster array file/ schema.

** Tensor schema

The /cluster tensor schema/ is not yet realized.  With already two implemented schema, a third seems excessive.  The main motivation is to unify persistence of data products in the WCT [[file:tensor-data-model.org][tensor data model]].  This involves writing object level converters to/from ~ITensorSet~ and using general purpose ~ITensorSet~ I/O components.  Already converters exist for ~IFrame~ and ~PointCloud~.  With and ~ICluster~ converter (and ~IDepo~), all major WCT data products would be in one data model.  The existing I/O for ~ITensorSet~ works with WCT iostreams.  Furthermore the tensor data model was designed to mimic HDF5 and so supporting that format would be easy and would bring random access file I/O.  A /cluster tensor schema/ is then, in the end, motivated.

The /cluster tensor schema/ is exected to be similar to the /cluster array schema/ but two representation choices exist. The choice comes down to adopting the type coercion of /cluster array schema/ to retain "monolithic" arrays or allowing each node attribute to retain its natural type and using individual "columnar" arrays.  This choice is made possible as ~ITensorSet~ allows for a heterotypical set of its ~ITensor~ constituents.

An related implementation choice for /cluster tensor schema/ also exists.  We may convert directly between ~ICluster~ and ~ITensorSet~ with new code or we may extend ~ClusterArrays~ to gain ~ITensorSet~ support and reuse/rework its code.  Then, there is a choice to retain ~ClusterArrays~ current use of ~boost::multi_array~ or to replace it those with ~PointCloud::DataSet~.  The motivator is that ~DataSet~ already has converters with ~ITensor~.  Choosing the "monolithic" type coercion approach would be easiest and may allow for compatibility between /tensor/ and /array/ files (useful for feeding GNN training).

** Implementation

The current situation is illustrated:

[[file:cluster-representation.png]]

Solid black represent existing nodes and edges.  Gray nodes are not implemented.  The "repr?" edge refers to the implementation choice in the last paragraph of the section just above.

Milestones for completing this support are:

- [X] extend ~ClusterArrays~ to provide round-trip with ~ICluster~.
- [X] test ~ClusterArrays~ to provide round-trip with ~ICluster~.
- [X] extend ~ClusterArrays~ to be initialized with from arrays.
- [X] extend ~ClusterFileSource~ to use above to read cluster array schema files.
- [ ] refactor ~ClusterArrays~ to utilize ~PointCloud::Dataset~ as internal storage.
- [ ] extend ~ClusterArrays~ to produce ~ITensorSet~ using ~TensorDM~ API to convert from ~Dataset~.
- [ ] extend ~ClusterArrays~ to initialize from ~ITensorSet~, again using ~TensorDM~.
- [ ] develop ~ClusterTensor~ and ~TensorCluster~ DFP graph node components.

