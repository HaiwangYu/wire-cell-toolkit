#+title: Wire-Cell Toolkit Noise

* Overview

WCT provides support for noise in various sub-packages

- ~WireCellAux/NoiseTools.h~ provides a ~Collector~ to form mean spectra
  of various flavors from noise-rich waveforms and ~Generator~ to
  produce waveforms given a $\sigma_k$ spectrum.

- ~WireCellSigProc/NoiseModeler.h~ provides a flow graph node using a
  ~Collector~ intended to run on data rich in noise, collect mean
  spectra and convert the result to *WCT noise spectra* and output them
  to file.  Also provided is the ~Undigitizer~ component which is
  effectively applies the inverse transform of ~Digitizer~ from ~gen~ and
  prepares voltage-level waves for input to the ~NoiseModeler~.

- ~WireCellGen/AddNoise.h~ provide flow graph nodes for incoherent and
  group-coherent noise generation by delegating to a "noise model"
  component to provide per-channel or per-channel-group spectra,
  respectively.  The ~GroupNoiseModel~ provides both interfaces and
  consumes a *WCT noise spectra* and a *WCT channel-groups*.  The
  ~EmpiricalNoiseModel~ consumes a *WCT noise spectra* and supports
  runtime change in electronics shaping and gain as well as wire
  length binning.


* WCT Noise Spectra

A *WCT noise spectra* are data describing mean spectral amplitudes and
related meta data.  They are provided to WCT C++ code as objects
following a schema described here.  The data is provided via WCT
configuration mechanism.

the *WCT noise spectra* are as an array of *spectrum objects* (eg as C++
representations of JSON via WCT's ~Configuration~ object).  Each
*spectrum object* follows an schema describing what types of attributes
it may have.  The attributes are categorized as *required*, *optional* or
*undefined*.  A spectrum object *must* contain all *required attributes*.  A
consumer of a WCT noise file *must* ignore *undefined attributes*.  An
*optional attribute* is one that is *required* for some consumers and
*undefined* for others.  Consumers of optional attributes *may* provide
default values for use if the attribute is unspecified.

** Required attributes

A *WCT spectral object* *must* provide these attributes:

- ~nsamples~ :: an integer number providing the size of (number of
  contiguous time series samples taken from) the waveforms used to
  form the mean spectral amplitude.  The ~nsamples~ *must not* count any
  zero padding that may have been applied to a waveform prior to
  forming the waveform contribution to the mean spectrum (ie, prior to
  applying the DFT).  The ~nsamples~ value is distinct from the size of
  the ~freqs~ and ~amps~ arrays.  If using ~NoiseTools::Collector~ the value
  for ~nsamples~ is provided by the ~.nticks()~ method.

- ~period~ :: a floating-point number providing the original sample
  period (inverse of sampling frequency) of the waveform expressed in
  the WCT system of units for [time].  (eg, 0.5*us for MicroBooNE).
  Note, ~period~ is not necessarily related to the values provided by
  the ~freqs~ array.

- ~freqs~ :: an array of floating-point numbers providing frequency
  values expressed in the WCT system of units for [frequency].  Note,
  WCT's base unit for [frequency] is *not* 1.0 Hz.  The size of this
  array *must* be equal to the size of the ~amps~ array and an element of
  ~freqs~ *must* provide the frequency at which the corresponding element
  of the ~amps~ array was sampled.  The ~freqs~ array *may* represent an
  irregular sampling and *may* be unordered.  It *should* include samples
  at or near the zero and Nyquist frequencies.  In particular it need
  not be a regular frequency sampling of ~1/period~ nor extend beyond
  the Nyquist frequency.

- ~amps~ :: an array of floating-point numbers providing an estimate of
  a mean spectral amplitude in units of [voltage] in the WCT system of
  units.  Note that here "amps" an abbreviation of "amplitude" and not
  "amperage".  The value of an element of ~amps~ may be derived from
  some sub-sampling or interpolation of an original distribution of
  DFT coefficients.  That is, an element of ~amps~ is the an average
  $\langle|X_k|\rangle,\ k\in [0,N^{(fft)}-1]$ with $N^{(fft)} \ge$
  ~nsamples~, over some number of waveforms of size ~nsamples~.  The
  inequality is typically due to zero-padding of the waveform prior to
  taking the DFT.  Note: in preparing ~amps~ the user is recommended to
  provide a number of waveforms approximately equal to ~nsamples~ in
  order to co-optimize spectral resolution and statistical stability.
  User is also recommended to utilize ~NoiseTools::Collector~ for
  low-level noise modeling code or execute a job using ~NoiseModeler~
  for a high-level development.

** Optional attributes required by ~EmpiricalNoiseModel~

The ~EmpiricalNoiseModel~ component requires these optional attributes:

- ~const~ :: a floating point number expressed in the same units as ~amps~
  and which provides an estimate of the mean white noise, and thus
  constant, spectral amplitude $\langle|X_w|\rangle$.

- ~gain~ :: a floating-point number giving the electronics gain from
  which the voltage waveforms originated.  The value must be in WCT
  system of units for [voltage]/[charge] (eg ~14.0*wc.mV/wc.fC~ as
  expressed in WCT Jsonnet configuration).  Note, this is *not* a
  unit-less, relative gain.

- ~shaping~ :: a floating-point number giving the electronics shaping
  time from which the waveforms originated.  The value must be
  expressed in WCT units for [time].

- ~plane~ :: an integer number giving the plane index counting from zero
  and in the direction of nominal drift.  Ie, U=0, V=1, W=2.  This
  value must indicate the plane in which a channel resides in order
  for the spectra to be applicable.

- ~wirelen~ :: a floating-point number giving a wire length expressed in
  the WCT system of units for [length].  This value should be
  representative of (eg, binned over) wires for which the associated
  spectrum applies.

** Optional attributes required by ~GroupNoiseModel~

The ~GroupNoiseModel~ provides a model interface for both coherent and
incoherent noise where spectra are grouped in an arbitrary way.  It
requires these optional attributes:

- ~group~ :: an integer identifying an abstract group to which channels
  may be associated.  The association to channels may be provided by a
  *WCT channel groups* array.  This attribute may also be provided with
  the key name ~groupID~.
  
* WCT channel groups

The ~GroupNoiseModel~ and potentially other components require
information on how to collect channels into distinct groups.  The user
may provide this information in the form of *WCT channel-groups* data
structures.  These are in the form of an array of *WCT channel-group*
objects, each of which has these *required* attributes:

- ~group~ :: an integer identifying a group.  Over the array, the set of
  ~group~ values *may* be discontinuous and may be unordered.  Each ~group~
  *must* be unique in the set.  Consumers of ~group~ shall not assume nor
  assign any semantic meaning to its value.  This attribute may also
  be provided with the key name ~groupID~.

- ~channels~ :: an array of integer values providing the channel ID
  numbers to associate as a group.  The channel IDs are as used in the
  *WCT wire object* configuration provided and described elsewhere.

* Providing the above data

Both WCT *noise spectra* and *channel group* objects may be provided
directly as a WCT configuration parameter (/eg/ with their values
directly expressed in Jsonnet files) or the parameter may hold a
string which shall be interpreted by the consumer as the name of a
file containing the data in a format that can be loaded by WCT (/eg/
~.jsonnet~, ~.json~, ~.json.bz2~, etc). 

Developers of components are recommended to satisfy this requirement
with code like:

#+begin_src C++
  void MyClass::configure(const WireCell::Configuration& cfg)
  {
      auto jgroups = cfg["groups"];
      if (jgroups.isNull()) {
          log->critical("no parameter \"group\" given");
          ++errors;
      }
      if (jgroups.isString()) {
          jgroups = Persist::load(map_file);
      }
      // ... code to use jgroups ...
  }
#+end_src

And, etc for *noise spectra*.

The end user is suggested to consider such things as file size, file
distribution requirements, frequency of change, number and types of
other users, etc, when choosing how to provide data this data.  In
particular, often channel groups may be expressed algorithmically and
thus best provided as Jsonnet.  Likewise, if spectra have an analytic
model, they are best provided as Jsonnet.  When JSON must be used, the
user is suggested to subsample large, detailed spectra to achieve file
size reduction while still faithfully representing the spectral shapes
with an acceptable resolution.


* Validation

** Round-trip

The "round-trip" consists of these steps:

- A set of fictional noise spectral amplitudes are defined.
- The set is interpreted both as coherent and incoherent noise.
- Separately, each are used to simulate a noise frame with a ~GroupedNoiseModel~
- Each are digitized to ADC and result saved to file.
- Each ADC frame is returned to voltage level with an ~Undigitizer~
- Each V frame is analyzed by a ~NoiseModeler~
  - Traces are judged by a ~NoiseRanker~
  - Survivors added to a ~NoiseCollector~
  - Finally, group spectra are saved to file.

*** Input spectra

The input spectra can be viewed with:

#+begin_example
wirecell-sigproc plot-noise-spectra \
  gen/test/test-noise-spectra.jsonnet orig.pdf
#+end_example

This will generate the spectra in Jsonnet.  It evaluates to a function with the following signature:

#+begin_src jsonnet
function(ngrps=10, nsamples=4096, nsave=64, period=0.5*wc.us, fpeak=0.1, rms=0.1*wc.volt)
#+end_src

- ~ngrps~ :: number of spectral groups to generate.  Each group will have ~grpnum/ngrps~ of the ~rms~.
- ~nsamples~ :: number of waveform time samples (number of "ticks") from which the spectrum is assumed to have originated.
- ~nsave~ :: how many sub-smampled points to produce.
- ~period~ :: the waveform sampling period ("tick")  from which the spectrum is assumed to have originated.
- ~peak~ :: the location of the spectral peak expressed as a fraction of the Nyquist frequency (~0.5/period~).
- ~rms~ :: the expected RMS from waveforms generated from the returned mean spectral amplitude.

*** Model details

Some understanding of the model is needed to provide proper values.  The spectrum shape in the frequency domain is modeled by a Rayleigh distribution with parameter $\sigma_s = \mathtt{peak} * F_{Nyquist}$ and an multiplicative scale $S$.  This is an ad-hoc choice of model and does not relate to the fact that each spectral bin $k$ is distributed also by a Rayleigh distribution with $\sigma_k,\ k\in[0,N-1]$ where $N$ is given by ~nsamples~.  The first two "raw" moments for each Rayleigh-distributed frequency bin are related through their $\sigma_k$ as:

\[\langle|X_k|\rangle = \sqrt{\frac{\pi}{2}}\sigma_k\]
and 

\[\langle|X_k|^2\rangle = 2\sigma_k^2\]

solving:

\[\langle|X_k|\rangle^2 = \frac{\pi}{4} \langle|X_k|^2\rangle,\ k\in[0,N-1]\]

We may calculate RMS on a per-waveform basis in either time or frequency domain

\[\sigma_{rms}^2 = \sum_k|x_k|^2/N = E/N = \sum_k|X_k|^2/N^2\]
We may form its average $\langle\cdot\rangle$ over many waveforms,

\[\langle \sigma_{rms}^2 \rangle = \sum_k \langle |X_k|^2 \rangle / N^2 = \sum_k \frac{4}{\pi} \langle |X_k| \rangle^2/N^2\]

Thus, we must choose $\sigma_s$ and $S$ so that the above sum gives desired $\langle\sigma_{rms}^2\rangle$.  We want to first "tune" $\sigma_s$ so that ~peak~ lands close to some real world noise spectrum peak so we take it as given and find $S$.

The Rayleigh PDF is $R(x;\sigma) = \frac{x}{\sigma^2}e^{-x^2/(2\sigma^2)}$ and our spectrum is $S\cdot R(X;\sigma_s) \triangleq S\cdot R_k = \langle|X_k|\rangle$.  Solving,

\[S^2 = \frac{\pi N^2 \langle\sigma_{rms}^2\rangle}{4 \sum_k R_k^2} \]

Thus the ~rms~ parameter is identified as providing the desired value of the $\sqrt{\langle\sigma_{rms}^2\rangle}$. An example with $N=4096,\ \sigma_{rms}=0.1\mathrm{V},\ \mathtt{peak}=0.1,\ T=0.5\mu\mathrm{s}$ and saving 65 subsampled points is:


#+ATTR_ORG: :width 800
[[file:test-noise-spectra-in-0.svg]]


*** Visualize the model

The above plot was made with a command like the following.  Any of the parameters of the model may be set from the command line, such as:
#+begin_example
wirecell-sigproc plot-noise-spectra \
  -A nsamples=1024 \
  -A nsave=100 \
  gen/test/test-noise-spectra.jsonnet \
  orig-specta.pdf
#+end_example

*** Performing the round-trip

A main configuration file for ~wire-cell~ is provided that uses the
above ~est-noise-spectra.jsonnet~ as the starting point for the
round-trip.  It can be exercised with default parameters like:

#+begin_example
$ wire-cell -c  gen/test/test-noise-roundtrip.jsonnet
$ ls -l test-noise-roundtrip-*{npz,json.bz2}
#+end_example

The job flow graph is:

#+ATTR_ORG: :width 800
[[file:test-noise-roundtrip-flow-graph.svg]]

It produces a cross product of $(inco,cohe) \otimes (adc,dac)$ where

- inco :: incoherent grouped noise (3 groups)
- cohe :: coherent grouped noise (10 groups)
- adc :: the simulated ADC
- dac :: the ADC rescaled back to voltage level

Each cross produces a ~.npz~ file and each noise type results in a
~.json.bz2~ file of output spectra.  These too can be visualized

#+begin_example
wirecell-sigproc plot-noise-spectra \
  test-noise-roundtrip-inco-spectra.json.bz2 \
  inco-spectra.pdf

wirecell-sigproc plot-noise-spectra \
  test-noise-roundtrip-cohe-spectra.json.bz2 \
  cohe-spectra.pdf
#+end_example
